methodBody,gptComment,groundTruth,Predicted_Comment
"public Map < String , String > getEffectiveConverterMap ( ) { Map < String , String > effectiveMap = new HashMap < String , String > ( ) ; // add the least specific map fist Map < String , String > defaultMap = getDefaultConverterMap ( ) ; if ( defaultMap != null ) { effectiveMap . putAll ( defaultMap ) ; } // contextMap is more specific than the default map Context context = getContext ( ) ; if ( context != null ) { @ SuppressWarnings ( ""unchecked"" ) Map < String , String > contextMap = ( Map < String , String > ) context . getObject ( CoreConstants . PATTERN_RULE_REGISTRY ) ; if ( contextMap != null ) { effectiveMap . putAll ( contextMap ) ; } } return effectiveMap ; }","This function generates a map of effective converters by combining a default map with a context specific map, prioritizing the context specific map.",Returns a map where the default converter map is merged with the map contained in the context .,Generates a map containing effective converters from the default model and context.
"private ArrayDouble . D3 addStagger ( ArrayDouble . D3 array , int dimIndex ) { //ADD: assert 0<=dimIndex<=2 int [ ] shape = array . getShape ( ) ; int [ ] newShape = new int [ 3 ] ; System . arraycopy ( shape , 0 , newShape , 0 , 3 ) ; newShape [ dimIndex ] ++ ; int ni = newShape [ 0 ] ; int nj = newShape [ 1 ] ; int nk = newShape [ 2 ] ; ArrayDouble . D3 newArray = new ArrayDouble . D3 ( ni , nj , nk ) ; //Index newIndex = newArray.getIndex(); //extract 1d array to be extended int n = shape [ dimIndex ] ; //length of extracted array double [ ] d = new double [ n ] ; //tmp array to hold extracted values int [ ] eshape = new int [ 3 ] ; //shape of extracted array int [ ] neweshape = new int [ 3 ] ; //shape of new array slice to write into for ( int i = 0 ; i < 3 ; i ++ ) { eshape [ i ] = ( i == dimIndex ) ? n : 1 ; neweshape [ i ] = ( i == dimIndex ) ? n + 1 : 1 ; } int [ ] origin = new int [ 3 ] ; try { //loop through the other 2 dimensions and ""extrapinterpolate"" the other for ( int i = 0 ; i < ( ( dimIndex == 0 ) ? 1 : ni ) ; i ++ ) { for ( int j = 0 ; j < ( ( dimIndex == 1 ) ? 1 : nj ) ; j ++ ) { for ( int k = 0 ; k < ( ( dimIndex == 2 ) ? 1 : nk ) ; k ++ ) { origin [ 0 ] = i ; origin [ 1 ] = j ; origin [ 2 ] = k ; IndexIterator it = array . section ( origin , eshape ) . getIndexIterator ( ) ; for ( int l = 0 ; l < n ; l ++ ) { d [ l ] = it . getDoubleNext ( ) ; //get the original values } double [ ] d2 = extrapinterpolate ( d ) ; //compute new values //define slice of new array to write into IndexIterator newit = newArray . section ( origin , neweshape ) . getIndexIterator ( ) ; for ( int l = 0 ; l < n + 1 ; l ++ ) { newit . setDoubleNext ( d2 [ l ] ) ; } } } } } catch ( InvalidRangeException e ) { //ADD: report error? return null ; } return newArray ; }","This function takes a 3D array and a dimension index as inputs and returns a new 3D array which has one more element in the specified dimension, through extraction and interpolation. In case of any invalid range error, the function will return null.",Add 1 to the size of the array for the given dimension . Use linear average and interpolation to fill in the values .,Returns a 3D array with an index and id.
"@ SuppressWarnings ( ""unchecked"" ) public static Map < String , String > deserializeOffsetMap ( String lastSourceOffset ) throws IOException { Map < String , String > offsetMap ; if ( lastSourceOffset == null || lastSourceOffset . isEmpty ( ) ) { offsetMap = new HashMap <> ( ) ; } else { offsetMap = JSON_MAPPER . readValue ( lastSourceOffset , Map . class ) ; } return offsetMap ; }","This function deserializes a string into a map representing source offsets, suppressing any unchecked warnings.",Deserialize String offset to Map of table to offset,Deserializes string representing source offsets.
"public void addPacketInterceptor ( PacketInterceptor packetInterceptor , PacketFilter packetFilter ) { if ( packetInterceptor == null ) { throw new NullPointerException ( ""Packet interceptor is null."" ) ; } interceptors . put ( packetInterceptor , new InterceptorWrapper ( packetInterceptor , packetFilter ) ) ; }","This function adds a packetInterceptor with a corresponding packetFilter to the interceptors map, throwing a NullPointerException if the packetInterceptor is null.",Registers a packet interceptor with this connection . The interceptor will be invoked every time a packet is about to be sent by this connection . Interceptors may modify the packet to be sent . A packet filter determines which packets will be delivered to the interceptor .,Adds a packet interceptor to the specified packetFilter.
"public static int getCharacterCountDecimal ( long integerValue , int scale ) { boolean isNeg = integerValue < 0 ; // Work out how many digits will be needed for the number, adding space for the minus sign, the decimal // point and leading zeros if needed. int totalDigits = BitHackUtils . getCharacterCountInt64 ( integerValue ) ; int totalLength = totalDigits ; if ( isNeg ) { totalDigits -- ; // Minus sign already accounted for. } if ( scale > 0 ) { totalLength ++ ; // For the decimal point. if ( scale >= totalDigits ) { // For the leading zeros (+ 1 for the zero before decimal point). totalLength += ( scale - totalDigits ) + 1 ; } } else { // Add a zero for each negative point in scale totalLength -= scale ; } return totalLength ; }","This function calculates the total number of characters needed to represent a long integer value to a specified decimal scale, accounting for the sign, decimal point, and any required leading zeros.",Calculates the number of ASCII characters that will be needed to represent a specified signed decimal number .,Calculate the number of characters the need to construct a long integer value to 0.
"public static boolean isActive ( final CountersReader countersReader , final int counterId , final long recordingId ) { final DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; if ( countersReader . getCounterState ( counterId ) == RECORD_ALLOCATED ) { final int recordOffset = CountersReader . metaDataOffset ( counterId ) ; return buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID && buffer . getLong ( recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET ) == recordingId ; } return false ; }","This function checks if a specific counter, identified by its ID and recording ID, is active in the CounterReader's meta-data buffer.",Is the recording counter still active .,Checks if the counter is active in the buffer provided by the reader.
"public static boolean isKeyColumn ( @ Nonnull final ColumnSet aColumnSet , @ Nullable final String sColumnID ) { if ( sColumnID != null ) for ( final Key aKey : getAllKeys ( aColumnSet ) ) for ( final KeyColumnRef aColumnRef : aKey . getColumnRef ( ) ) if ( aColumnRef . getRef ( ) instanceof Column ) if ( ( ( Column ) aColumnRef . getRef ( ) ) . getId ( ) . equals ( sColumnID ) ) return true ; return false ; }","This function checks if the provided column ID is a key column in the given column set, returning true if it is, false otherwise.",Check if the passed column ID is a key column in the specified column set,Returns true if column id is a string or false unless otherwise specified.
public Set < String > getClustersOwnedByServer ( final String iNodeName ) { final Set < String > clusters = new HashSet < String > ( ) ; for ( String cl : getClusterNames ( ) ) { if ( iNodeName . equals ( getClusterOwner ( cl ) ) ) clusters . add ( cl ) ; } return clusters ; },This function retrieves all cluster names owned by a specified server node.,Returns the set of clusters where server is the owner .,Returns cluster names specifying server nodes for the specified server n.
"public void mergeSort ( int index , int lo , int hi , Comparator cmp ) { chooseComparer ( index , cmp ) ; super . mergeSort ( lo , hi - 1 ) ; }","This function sorts an array within the specified range of indices 'lo' to 'hi' using merge sort algorithm and a comparator defined by 'cmp', after choosing the comparator using the 'chooseComparer' method.",Sort the arrays using an in - place merge sort .,Sort an array from lo to hi from the specified range of indices.
"public static void main ( final String [ ] args ) { loadPropertiesFiles ( args ) ; final ShutdownSignalBarrier barrier = new ShutdownSignalBarrier ( ) ; final MediaDriver . Context ctx = new MediaDriver . Context ( ) ; ctx . terminationHook ( barrier :: signal ) ; try ( MediaDriver ignore = MediaDriver . launch ( ctx ) ) { barrier . await ( ) ; System . out . println ( ""Shutdown Driver..."" ) ; } }","This function initiates the main program, loads property files, sets up a shutdown signal barrier, sets a termination hook to signal the barrier, launches the media driver, awaits its termination, and then prints ""Shutdown Driver..."".",Start Media Driver as a stand - alone process .,Shutdown signal barrier.
public void invalidateAll ( Predicate < ? super JwtContext > predicate ) { cache . asMap ( ) . entrySet ( ) . stream ( ) . map ( entry -> entry . getValue ( ) . getKey ( ) ) . filter ( predicate :: test ) . map ( JwtContext :: getJwt ) . forEach ( cache :: invalidate ) ; },This function invalidates all entries in the cache that meet the specified condition described in the predicate.,Discards any cached principal for the collection of credentials satisfying the given predicate .,invalidates all entries in the cache that are subject to the specified predicate.
public boolean attachTimer ( TimerID timerID ) { final Node node = getAttachedTimersNode ( true ) ; if ( ! node . hasChild ( timerID ) ) { node . addChild ( Fqn . fromElements ( timerID ) ) ; return true ; } else { return false ; } },"This function attaches a timer to a node if not already attached and returns true, otherwise it returns false.",Attaches a timer,Attach a timer to the given node.
"private void allocateCharBuffer ( ) { if ( bufferSize == 0 ) return ; if ( bufferSize > MAX_BUFFER_SIZE ) { buf = new CharBuffer ( new char [ bufferSize ] , 0 , bufferSize ) ; } else { buf = getCharBufferThreadLocalPool ( ) . allocate ( bufferSize ) ; } }","This function allocates memory for a character buffer, using thread-local pool for buffer sizes less than or equal to the maximum size, otherwise creating a new buffer.",END PWC 6512276,Set the memory for a specific character buffer.
"public void writeXML ( NetcdfDataset ncd , OutputStream os , boolean showCoords , String uri ) throws IOException { // Output the document, use standard formatter //XMLOutputter fmt = new XMLOutputter(""  "", true); //fmt.setLineSeparator(""\n""); XMLOutputter fmt = new XMLOutputter ( Format . getPrettyFormat ( ) ) ; fmt . output ( makeDocument ( ncd , showCoords , uri ) , os ) ; }","This function writes the specified NetcdfDataset to the provided OutputStream as XML, with options to show coordinates and specify the URI, using pretty formatting.",Write a NetcdfDataset as an NcML - G document to the specified stream .,Write the given data set to the exported stream.
"protected ActivityContextInterface getACI ( Object activity ) throws NullPointerException , UnrecognizedActivityException , FactoryException { if ( activity == null ) { throw new NullPointerException ( ""null activity object"" ) ; } ActivityHandle handle = null ; for ( ResourceAdaptorEntity raEntity : sleeContainer . getResourceManagement ( ) . getResourceAdaptorEntitiesPerType ( resourceAdaptorTypeID ) ) { handle = raEntity . getResourceAdaptorObject ( ) . getActivityHandle ( activity ) ; if ( handle != null ) { ActivityContextHandle ach = new ResourceAdaptorActivityContextHandleImpl ( raEntity , handle ) ; ActivityContext ac = sleeContainer . getActivityContextFactory ( ) . getActivityContext ( ach ) ; if ( ac != null ) { return ac . getActivityContextInterface ( ) ; } break ; } } throw new UnrecognizedActivityException ( activity . toString ( ) ) ; }","This function retrieves the ActivityContextInterface for a given activity object, throwing exceptions for null activity, unrecognized activity, and errors during the interface lookup from the ResourceAdaptorEntity list.",This method returns the aci for the specified activity if exists it should be invoked by each impl of methods of an ra type aci factory .,Returns the ActivityContextInterface for an activity object.
"static public String fqnPrefix ( String fqn ) { int structindex = fqn . lastIndexOf ( ' ' ) ; int groupindex = fqn . lastIndexOf ( ' ' ) ; if ( structindex >= 0 ) return fqn . substring ( 0 , structindex ) ; else return fqn . substring ( 0 , groupindex ) ; }",This function retrieves the prefix of a fully qualified name (fqn) string by splitting at the last space.,return prefix name part of an fqn ; result will be escaped .,Returns the prefix of the fully qualified name.
"public static boolean insideOf ( String start , String inStr , String end ) { return Chr . insideOf ( FastStringUtils . toCharArray ( start ) , FastStringUtils . toCharArray ( inStr ) , FastStringUtils . toCharArray ( end ) ) ; }","This function checks if a specific string (inStr) is found within a defined range in the main string, which is defined by the start and end parameters.",Checks to see if a string is inside of another,This method checks if a specific string is found in the range defined by the main string.
public static HttpRequest head ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( destination ) ; },This function creates and returns a new HTTP request with the HEAD method to the specified destination.,Builds a HEAD request .,Create and return a HTTP request for the specified destination by using the HEAD method.
"public static Map < String , Object > getDefaultValues ( Schema schema ) throws SchemaRegistryException { Map < String , Object > defaultValues = new HashMap <> ( ) ; try { defaultValues . putAll ( AvroTypeUtil . getDefaultValuesFromSchema ( schema , new HashSet < String > ( ) ) ) ; } catch ( IOException e ) { throw new SchemaRegistryException ( e ) ; } return defaultValues ; }","This function retrieves the default values for a given schema, returning them as a map with string keys and object values, throwing a SchemaRegistryException if there is an IOException.",Helper method to extract default values from a Schema . This is normally done in DataGeneratorFormat validation however we have to do it at runtime for Schema Registry .,Returns default values for schema schema.
"@ SuppressWarnings ( ""deprecation"" ) static void addTransformations ( ModelVersion version , ResourceTransformationDescriptionBuilder builder ) { if ( JGroupsModel . VERSION_5_0_0 . requiresTransformation ( version ) ) { builder . getAttributeBuilder ( ) . setDiscard ( DiscardAttributeChecker . UNDEFINED , Attribute . STATISTICS_ENABLED . getDefinition ( ) ) . addRejectCheck ( RejectAttributeChecker . DEFINED , Attribute . STATISTICS_ENABLED . getDefinition ( ) ) . end ( ) ; } if ( JGroupsModel . VERSION_3_0_0 . requiresTransformation ( version ) ) { AttributeConverter typeConverter = new AttributeConverter . DefaultAttributeConverter ( ) { @ Override protected void convertAttribute ( PathAddress address , String name , ModelNode value , TransformationContext context ) { if ( ! value . isDefined ( ) ) { value . set ( address . getLastElement ( ) . getValue ( ) ) ; } } } ; builder . getAttributeBuilder ( ) . setDiscard ( new DiscardAttributeChecker . DiscardAttributeValueChecker ( Attribute . MODULE . getDefinition ( ) . getDefaultValue ( ) ) , Attribute . MODULE . getDefinition ( ) ) . addRejectCheck ( RejectAttributeChecker . DEFINED , Attribute . MODULE . getDefinition ( ) ) . setValueConverter ( typeConverter , DeprecatedAttribute . TYPE . getDefinition ( ) ) . end ( ) ; builder . addRawOperationTransformationOverride ( MapOperations . MAP_GET_DEFINITION . getName ( ) , new SimpleOperationTransformer ( new LegacyPropertyMapGetOperationTransformer ( ) ) ) ; for ( String opName : Operations . getAllWriteAttributeOperationNames ( ) ) { builder . addOperationTransformationOverride ( opName ) . inheritResourceAttributeDefinitions ( ) . setCustomOperationTransformer ( new LegacyPropertyWriteOperationTransformer ( ) ) ; } } PropertyResourceDefinition . buildTransformation ( version , builder ) ; }","This function adds transformations to the provided model version and builder while suppressing deprecation warnings, including transformations for statistics and modules, with a check for specific model versions, and includes a default type converter for undefined values.",Builds transformations common to both stack protocols and transport .,Adds a builder and transforms the model versions.
"public List < SDVariable > diff ( List < SDVariable > i_v1 ) { List < SDVariable > vals = doDiff ( i_v1 ) ; if ( vals == null ) { throw new IllegalStateException ( ""Error executing diff operation: doDiff returned null for op: "" + this . opName ( ) ) ; } val outputVars = args ( ) ; for ( int i = 0 ; i < vals . size ( ) ; i ++ ) { SDVariable var = outputVars [ i ] ; SDVariable grad = var . getGradient ( ) ; if ( grad != null ) { SDVariable gradVar = f ( ) . add ( grad , vals . get ( i ) ) ; try { vals . set ( i , gradVar ) ; } catch ( UnsupportedOperationException e ) { throw new UnsupportedOperationException ( ""Use a mutable list when returning values from "" + this . getClass ( ) . getSimpleName ( ) + "".doDiff (e.g. Arrays.asList instead of Collections.singletonList)"" , e ) ; } sameDiff . setGradientForVariableName ( var . getVarName ( ) , gradVar ) ; } else { SDVariable gradVar = vals . get ( i ) ; sameDiff . updateVariableNameAndReference ( gradVar , var . getVarName ( ) + ""-grad"" ) ; sameDiff . setGradientForVariableName ( var . getVarName ( ) , gradVar ) ; sameDiff . setForwardVariableForVarName ( gradVar . getVarName ( ) , var ) ; } } return vals ; }","This function performs differential operations for a list of SDVariable objects, updating the gradient for each variable and handling instances where no gradient is found or a null value is returned.",Perform automatic differentiation wrt the input variables,Servo differential - operation for list of SDVariable objects.
"protected void validatePicture ( MediaPicture picture ) { // if the picture is NULL, throw up if ( picture == null ) throw new IllegalArgumentException ( ""The picture is NULL."" ) ; // if the picture is not complete, throw up if ( ! picture . isComplete ( ) ) throw new IllegalArgumentException ( ""The picture is not complete."" ) ; // if the picture is an invalid type throw up PixelFormat . Type type = picture . getFormat ( ) ; if ( ( type != getPictureType ( ) ) && ( willResample ( ) && type != mToImageResampler . getOutputFormat ( ) ) ) throw new IllegalArgumentException ( ""Picture is of type: "" + type + "", but must be "" + getPictureType ( ) + ( willResample ( ) ? "" or "" + mToImageResampler . getOutputFormat ( ) : """" ) + ""."" ) ; }","This function checks a MediaPicture object for null value, completeness, and proper formatting, throwing an IllegalArgumentException if any of these checks fail.",Test that the passed picture is valid and conforms to the converters specifications .,Checks the value of this file.
"public void initOnce ( HttpServletRequest req ) throws SendError { if ( once ) return ; once = true ; log . info ( getClass ( ) . getName ( ) + "" GET initialization"" ) ; if ( this . tdsContext == null ) throw new SendError ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR , ""Cannot find TDS Context"" ) ; // Get server host + port name StringBuilder buf = new StringBuilder ( ) ; buf . append ( req . getServerName ( ) ) ; int port = req . getServerPort ( ) ; if ( port > 0 ) { buf . append ( "":"" ) ; buf . append ( port ) ; } this . server = buf . toString ( ) ; // Obtain servlet path info String tmp = HTTPUtil . canonicalpath ( req . getContextPath ( ) ) ; this . threddsname = HTTPUtil . nullify ( HTTPUtil . relpath ( tmp ) ) ; tmp = HTTPUtil . canonicalpath ( req . getServletPath ( ) ) ; this . requestname = HTTPUtil . nullify ( HTTPUtil . relpath ( tmp ) ) ; if ( this . threddsname == null ) this . threddsname = DEFAULTSERVLETNAME ; // Get the upload dir File updir = tdsContext . getUploadDir ( ) ; if ( updir == null ) { log . warn ( ""No tds.upload.dir specified"" ) ; this . uploaddir = null ; } else this . uploaddir = HTTPUtil . canonicalpath ( updir . getAbsolutePath ( ) ) ; // Get the download dir File downdir = tdsContext . getDownloadDir ( ) ; if ( downdir == null ) { log . warn ( ""No tds.download.dir specified"" ) ; this . downloaddir = null ; } else this . downloaddir = HTTPUtil . canonicalpath ( downdir . getAbsolutePath ( ) ) ; }","This function initializes the HTTP request context once, obtaining server, servlet path, and directory details for upload and download, and logs warnings if certain pieces of information aren't specified.",Invoked on first get so that everything is available especially Spring stuff .,This method initializes the HTTP request context. The method will allow to open the server and open all HTTP requests to the specified information s names based on the given information provided ; and does not expect that the information is being read properly - uses the same method if there is no such thing as the name / server config!
"@ RequestMapping ( value = ""/secure/deletePermission.htm"" ) public ModelAndView deletePermission ( @ RequestParam ( ""contactId"" ) long contactId , @ RequestParam ( ""sid"" ) String sid , @ RequestParam ( ""permission"" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( ""contact"" , contact ) ; model . put ( ""sid"" , sidObject ) ; model . put ( ""permission"" , permission ) ; return new ModelAndView ( ""deletePermission"" , ""model"" , model ) ; }","This function deletes a specific permission associated with a contact and sid, and then presents the updated information via the ""deletePermission"" view.",Deletes a permission,Delete an existing contact and send the information to the contact.
"public RTHtml < RTImage , RTAudio , RTVideo > convert ( final Spanned text , RTFormat . Html rtFormat ) { mText = text ; mRTFormat = rtFormat ; mOut = new StringBuilder ( ) ; mImages = new ArrayList <> ( ) ; mParagraphStyles . clear ( ) ; // convert paragraphs convertParagraphs ( ) ; return new RTHtml <> ( rtFormat , mOut . toString ( ) , mImages ) ; }","This function takes a text in Spanned format and an RTFormat and converts it into RTHtml format with embedded images, audio, and video.",Converts a spanned text to HTML,"This method converts a text to rTHtml format with embedded images, audio and videos."
"private List < ValidatorMetaData > extractValidatorMetaData ( Class < ? > clazz , String propertyName , List < ValidatorMetaData > validatorMetaDataList ) { /* If the meta-data was not found, then generate it. */ if ( validatorMetaDataList == null ) { // if not found /* Read the annotation from the class based on the property name. */ Collection < AnnotationData > annotations = Annotations . getAnnotationDataForFieldAndProperty ( clazz , propertyName , this . validationAnnotationPackages ) ; /* Extract the POJO based meta-data from the annotation. */ validatorMetaDataList = extractMetaDataFromAnnotations ( annotations ) ; } return validatorMetaDataList ; }","This function retrieves validator meta-data for a specific class property; if the data does not exist, it generates it by reading annotations from the class.",Extract BaseValidator Meta Data .,Get validator metadata for a class property.
"protected String pull ( Node n , String name ) { NamedNodeMap map = n . getAttributes ( ) ; Node attr = map . getNamedItem ( name ) ; if ( attr == null ) return null ; return attr . getNodeValue ( ) ; }","This function retrieves the value of a specified attribute from a given node in a NamedNodeMap, returning null if the attribute does not exist.",XML Attribute utilities,Returns value from attribute given node.
"public static Class < ? > childClassOf ( final Class < ? > parentClass , final Object instance ) { if ( instance == null || instance == Object . class ) { return null ; } if ( parentClass != null ) { if ( parentClass . isInterface ( ) ) { return null ; } } Class < ? > childClass = instance . getClass ( ) ; while ( true ) { Class < ? > parent = childClass . getSuperclass ( ) ; if ( parent == parentClass ) { return childClass ; } if ( parent == null ) { return null ; } childClass = parent ; } }","This function returns the child class of a given parent class and instance, returning null if the instance is null, the instance is of type Object, or the parentClass is an interface.",Returns the class of the immediate subclass of the given parent class for the given object instance ; or null if such immediate subclass cannot be uniquely identified for the given object instance .,Returns the child class of the parent class.
"public void writeBytes ( byte [ ] bytes , int len ) throws IOException { outputBytes ( bytes , 0 , len ) ; if ( this . checksummode . enabled ( ChecksumMode . DAP ) ) { this . checksum . update ( bytes , 0 , len ) ; if ( DUMPCSUM ) { System . err . print ( ""SSS "" ) ; for ( int i = 0 ; i < len ; i ++ ) { System . err . printf ( ""%02x"" , bytes [ i ] ) ; } System . err . println ( ) ; } } }","Writes specified length of bytes to output, and updates the checksum if the mode is enabled.",Write out a set of bytes,Write the given bytes to the output.
"public UrlBuilder queryParam ( String name , Number value ) { if ( value != null ) { return queryParam ( name , value . toString ( ) ) ; } else { return null ; } }","This function allows to add a query parameter with specified 'name' and 'number' value to a URL, returning null if the value is null.",Create a query parameter with a number value .,Add a string representation of the given name to the URL.
"public Bitmap drawTile ( int x , int y , int zoom ) { Bitmap bitmap ; if ( isIndexQuery ( ) ) { bitmap = drawTileQueryIndex ( x , y , zoom ) ; } else { bitmap = drawTileQueryAll ( x , y , zoom ) ; } return bitmap ; }","// This function draws a tile at a specified x, y location, with a particular zoom level, using either an index or an all-encompassing query based on the requirements.",Draw a tile bitmap from the x y and zoom level,Draw a tile at the specified location using the given index or the above specified zoom level.
"public void cleanUp ( ) { if ( oos != null ) { try { oos . close ( ) ; } catch ( IOException e ) { LogLog . error ( ""Could not close oos."" , e ) ; } oos = null ; } if ( connector != null ) { // LogLog.debug(""Interrupting the connector.""); connector . interrupted = true ; connector = null ; // allow gc } }","This function is designed to close the object output stream 'oos' and interrupt a running 'connector', then setting both to null, to free up system resources and allow for garbage collection.",Drop the connection to the remote host and release the underlying connector thread if it has been created .,This method allows to close the connector and release the incoming objects. Both of these methods are configured to be null if necessary ; otherwise it will be used to access the internal stream - free resources pending on the external stream at the same point!
"private static boolean isSystemClass ( String name , List < String > packageList ) { boolean result = false ; if ( packageList != null ) { String canonicalName = ClassLoaderUtil . canonicalizeClassOrResource ( name ) ; for ( String c : packageList ) { boolean shouldInclude = true ; if ( c . startsWith ( ""-"" ) ) { c = c . substring ( 1 ) ; shouldInclude = false ; } if ( canonicalName . startsWith ( c ) ) { if ( c . endsWith ( ""."" ) // package || canonicalName . length ( ) == c . length ( ) // class || canonicalName . length ( ) > c . length ( ) // nested && canonicalName . charAt ( c . length ( ) ) == ' ' ) { if ( shouldInclude ) { result = true ; } else { return false ; } } } } } return result ; }",This function checks if a given class name is part of a system package by comparing it with a list of packages; it can also exclude specified packages starting with a '-'.,Checks if a class should be included as a system class .,Check if class name is part of package.
"protected Object convertType ( final Object value , final Class targetType ) { final Class valueClass = value . getClass ( ) ; if ( valueClass == targetType ) { return value ; } try { return TypeConverterManager . get ( ) . convertType ( value , targetType ) ; } catch ( Exception ex ) { if ( ! strictTypes ) { return null ; } throw new JsonException ( ""Type conversion failed"" , ex ) ; } }",This function tries to convert a given object value to a specified target type and returns the converted object or throws an exception if the type conversion fails and strictTypes is true.,Converts type of the given value .,Convert type to target type by type.
public static String getPackageName ( Object o ) { return ( o == null ) ? null : getClassPackageName ( o . getClass ( ) ) ; },"This function returns the package name of a given object's class, or null if the object itself is null.",Returns the package name of the object s class .,Returns the package name of the given object.
public final void addParamTemplate ( final ParameterizedTemplateModel paramTemplate ) { if ( paramTemplates == null ) { paramTemplates = new ArrayList < ParameterizedTemplateModel > ( ) ; } paramTemplates . add ( paramTemplate ) ; },"This function adds a new parameterized template to the list of parameter templates, initializing the list if it is null.",Adds another template to the list . If the list does not exist it will be created .,Add a template to the parameterized list of parameter templates.
"public static Object getSbbUsageParameterSet ( SbbEntity sbbEntity , String name ) throws UnrecognizedUsageParameterSetNameException { if ( logger . isTraceEnabled ( ) ) { logger . trace ( ""getSbbUsageParameterSet(): serviceId = "" + sbbEntity . getSbbEntityId ( ) . getServiceID ( ) + "" , sbbID = "" + sbbEntity . getSbbId ( ) + "" , name = "" + name ) ; } return getServiceUsageMBeanImpl ( sbbEntity . getSbbEntityId ( ) . getServiceID ( ) ) . getInstalledUsageParameterSet ( sbbEntity . getSbbId ( ) , name ) ; }","This function retrieves the SBB usage parameter set based on a given SBB entity and name, and throws an exception if the parameter set name is unrecognized.",SBB USAGE PARAMS,Returns the usage parameter set for the specified SBB entity. The usage parameters should not be changed if the parameter sets name is not recognized ; this will result in a new parameter setting for this SBS entity and the given SNB entity.
"public Map < String , String > toExtraMetaData ( ) { final Map < String , String > map = new HashMap < String , String > ( ) ; map . put ( THRIFT_CLASS , getThriftClass ( ) . getName ( ) ) ; map . put ( THRIFT_DESCRIPTOR , descriptor . toJSON ( ) ) ; return map ; }","This function creates a new hashmap to store extra metadata, with the key-value pairs being the Thrift class name and the Thrift descriptor's JSON representation.",generates a map of key values to store in the footer,Create a hashmap for the metadata metadata.
private void getMoreBytes ( ) throws IOException { currentOffset = 0 ; // reset current array offset to 0 int bytesRead = 0 ; // bytes read so far int lookingFor = 0 ; // character in endSequence to look for for ( ; bytesRead < lineBuf . length ; bytesRead ++ ) { int c = in . read ( ) ; if ( c == - 1 ) break ; // break on EOL and return what we have so far lineBuf [ bytesRead ] = ( byte ) c ; if ( lineBuf [ bytesRead ] == endSequence [ lookingFor ] ) { lookingFor ++ ; if ( lookingFor == endSequence . length ) { endFound = true ; break ; } } else if ( lineBuf [ bytesRead ] == endSequence [ 0 ] ) { // CHANGED JC lookingFor = 1 ; } else { lookingFor = 0 ; } } bytesRemaining = bytesRead ; // number of bytes we've read },"This function is used to read from the input until it finds a specified end sequence or it has read the maximum number of bytes, simultaneously updating the current offset and status of end sequence found.",Get more bytes into buffer . Stop when endSequence is found .,Reads the end sequence from the input stream.
"private int loadData ( ) { if ( ! headerLoaded ) return - 1 ; if ( dataLoaded ) return 0 ; InputStream s = stream ; if ( s == null ) return - 1 ; try { /* read in the data */ for ( int i = 0 ; i < nrecords ; i ++ ) { /* read the data record indicator */ byte recbyte = ds . readByte ( ) ; if ( recbyte == 0x20 ) { for ( int j = 0 ; j < nfields ; j ++ ) { data [ j ] . readRowN ( ds , i ) ; } } else { /* a deleted record */ nrecords -- ; i -- ; } } dataLoaded = true ; } catch ( java . io . IOException e ) { close ( s ) ; return - 1 ; } finally { close ( s ) ; } return 0 ; }","This function attempts to load data from a stream into records and fields, managing header loading state, and error handling.",Load the dbase file data .,Load fields and fields from a stream.
public void useProfile ( final String profile ) { if ( profile == null ) { return ; } if ( this . enabledProfiles == null ) { this . enabledProfiles = new HashSet <> ( ) ; } this . enabledProfiles . add ( profile ) ; },"This function checks if a given profile is null, initializes the 'enabledProfiles' set if necessary, and then adds the non-null profile to the 'enabledProfiles' set.",Enables single profile .,This method allows you to specify the null profile in the specified profile.
public Collection < V > getInwardEdgeVertices ( V vertex ) { Collection < V > inwardEdgeVerticesForVertex = inwardEdgesVertices . get ( vertex ) ; return inwardEdgeVerticesForVertex != null ? inwardEdgeVerticesForVertex : Collections . < V > emptySet ( ) ; },"This function retrieves the collection of vertices connected by inward edges to the specified vertex, returning an empty set if no such vertices exist.",Returns the inward flowing edge vertices .,Returns the vertice collection for the specified vertex.
"public E poll ( ) { /*log.fine(""public E poll(): called"");*/ // This is used to keep track of the level of the list that is found to have data in it. int currentLevel = 0 ; while ( true ) { // This is used to locate the marker head of a list that contains data. Marker < E > h = null ; // This is used to locate the potential data node of a list with data in it. Another thread may already // have taken this data. Node < E > first = null ; // Second data item, may also be tail marker, first data item of next list, or null at end of last list. Node < E > second = null ; // Loop down any empty lists at the front of the queue until a list with data in it is found. for ( ; currentLevel < n ; currentLevel ++ ) { h = markers [ currentLevel ] ; first = h . getNext ( ) ; second = first . getNext ( ) ; // Check if the list at the current level is not empty and should be tried for data. if ( ! h . isEmpty ( markers [ currentLevel + 1 ] ) ) { break ; } // Check if the current level is empty and is the last level, in which case return null. else if ( currentLevel == ( n - 1 ) ) { // log.info(""returning null from level loop.""); return null ; } // Else if the current level is empty loop to the next one to see if it has data. } /*log.fine(""current poll level = "" + currentLevel);*/ // This is used to locate the tail of the list that has been found with data in it. Node < E > t = markers [ currentLevel + 1 ] . getTail ( ) ; // Check that the first data item has not yet been taken. Another thread may already have taken it, // in which case performing a relatively expensive cas on the head will fail. If first is still intact // then second will be intact too. if ( first == h . getNext ( ) ) { // Check if the queue has become empty. if ( h . isEmpty ( markers [ currentLevel + 1 ] ) ) { // Another thread has managed to take data from the queue, leaving it empty. // First won't be null. It may point to tail though... if ( first == null ) { // Don't want to return here, want to try the next list. The list loop has a return null // once it gets to the end to take care of that. // log.info(""returning null as first == null""); return null ; } else { // Not sure yet why castail here? Does this repair a broken tail ref left after the last item // was taken? markers [ currentLevel + 1 ] . casTail ( t , first ) ; } } // The queue contains data, so try to move its head marker reference from the first data item, onto the // second item (which may be data, or the tail marker). If this succeeds, then the first data node // has been atomically extracted from the head of the queue. else if ( h . casNext ( first , second ) ) { // h Does not refer to an empty queue, so first must be a data node. DataNode < E > firstDataNode = ( ( DataNode < E > ) first ) ; E item = firstDataNode . getItem ( ) ; // Even though the empty test did not indicate that the list was empty, it may contain null // data items, because the remove method doesn't extract nodes on a remove. These need to be skipped // over. Could they be removed here? if ( item != null ) { firstDataNode . setItem ( null ) ; /*log.fine(""returing item = "" + item);*/ // Decrement the queue size count. count . decrementAndGet ( ) ; return item ; } // else skip over deleted item, continue trying at this level. Go back an retry starting from same // level. List at this level may now be empty, or may get the next item from it. // else skip over marker element. just make markers return null for item to skip them? No, because // need to advance currentLevel and get head and tail markers for the next level. but then, next // level advance will occur when this level is retried and found to be empty won't it? } } } }","This function retrieves and removes data from the head of a multi-level queue safely across multiple threads. It maintains an atomic operation by looping through each level of the queue, checks if they're empty, if not, it attempts to move the head of the markers to the next data node, extracts the data and returns it; and it also ensures skipping over null data items created by removes.",Retrieves and removes the head of this queue or null if this queue is empty .,Remove all the markers from the next queue.
public void skipWhiteSpace ( ) { while ( pos < s . length ( ) && Character . isWhitespace ( s . charAt ( pos ) ) ) ++ pos ; },This function advances the position in the string 's' to the next non-white space character.,Skips the next sequence of white space in s . An exception is not thrown if there is no matching white space .,This method returns the white space next.
"public static int parseInt ( String buffer , int from , int to ) { return CharScanner . parseInt ( FastStringUtils . toCharArray ( buffer ) , from , to ) ; }","This function converts a substring of a given string into an integer, with the substring boundaries specified by the 'from' and 'to' parameters.",parse an int within a range,converts a substring into an integer.
"void copyins ( State old , State newState ) { Arc a ; assert old != newState ; for ( a = old . ins ; a != null ; a = a . inchain ) { cparc ( a , a . from , newState ) ; } }",This function copies all incoming arcs from an old state to a new state in a given state machine.,copyins - copy all in arcs of a state to another state,Copys state arcs from old state to new state
"public void setFeatureStyles ( String featureTable , long featureId , FeatureStyles featureStyles ) { if ( featureStyles != null ) { setStyles ( featureTable , featureId , featureStyles . getStyles ( ) ) ; setIcons ( featureTable , featureId , featureStyles . getIcons ( ) ) ; } else { deleteStyles ( featureTable , featureId ) ; deleteIcons ( featureTable , featureId ) ; } }","This function sets the styles and icons for a specific feature in a given table if the ""featureStyles"" parameter is not null, otherwise it deletes the existing styles and icons for that feature.",Set the feature styles for the feature table and feature id,Sets the styles and icons for the given feature.
"public void setId ( String v ) { if ( ConceptType_Type . featOkTst && ( ( ConceptType_Type ) jcasType ) . casFeat_id == null ) jcasType . jcas . throwFeatMissing ( ""id"" , ""edu.cmu.lti.oaqa.type.kb.ConceptType"" ) ; jcasType . ll_cas . ll_setStringValue ( addr , ( ( ConceptType_Type ) jcasType ) . casFeatCode_id , v ) ; }","This function is setting an ID (string 'v') to a ConceptType, while also performing a null-check to ensure that the 'id' feature is not missing.",setter for id - sets The id of the concept type .,Set an ID to be used for typing concepts in the String.
"public String getJobStatus ( final String jobId , final String title ) throws IOException , InterruptedException { final AtomicReference < String > ar = new AtomicReference < String > ( ) ; IWorkbench wb = PlatformUI . getWorkbench ( ) ; IProgressService ps = wb . getProgressService ( ) ; try { ps . busyCursorWhile ( new IRunnableWithProgress ( ) { public void run ( IProgressMonitor pm ) throws InterruptedException { pm . beginTask ( ""Waiting for Job "" + jobId + "":\n\n"" + title , STATUS_REQUEST_TIMEOUT ) ; pm . subTask ( title ) ; long startTime = System . currentTimeMillis ( ) ; long stopTime = startTime ; do { try { // send a Job Status request every STATUS_REQUEST_DELAY milliseconds Thread . sleep ( STATUS_REQUEST_DELAY ) ; String response = httpGet ( ""jobs/"" + jobId ) ; JsonObject jo = JsonObject . readFrom ( response ) ; String status = jo . get ( ""status"" ) . asString ( ) ; String result = jo . get ( ""result"" ) . asString ( ) ; if ( ""null"" . equals ( result ) ) { if ( ! ""SUCCESS"" . equals ( status ) ) result = null ; } if ( status != null && result != null ) ar . set ( status + "":"" + result ) ; stopTime = System . currentTimeMillis ( ) ; pm . worked ( STATUS_REQUEST_DELAY ) ; Activator . println ( ""status="" + status ) ; Activator . println ( ""result="" + result ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } if ( pm . isCanceled ( ) ) throw new InterruptedException ( ""Operation canceled"" ) ; } while ( ar . get ( ) == null && stopTime - startTime < STATUS_REQUEST_TIMEOUT ) ; pm . done ( ) ; Activator . println ( ""\n----------------------------------\n"" + ""Job "" + jobId + ""\n"" + title + ""\ncompleted in "" + ( stopTime - startTime ) / 1000.0 + "" sec\n"" + ""Status: "" + ar . get ( ) + ""\n----------------------------------\n"" ) ; } } ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; return null ; } return ar . get ( ) ; }","This function, `getJobStatus`, checks the status of a specific job identified by `jobId` and `title` at repeated intervals until a result is achieved or a timeout occurs. It throws exceptions for IO issues and Interruptions.",Sends a job status request to the KIE Server .,Checks the status of the job.
"public static < K , V > PersistentTreeMap < K , V > empty ( Comparator < ? super K > c ) { return new PersistentTreeMap <> ( c , null , 0 ) ; }",This function creates and returns an empty PersistentTreeMap with a specified comparator.,Returns a new empty PersistentTreeMap that will use the specified comparator .,Create and return a PersistentTreeMap.
"protected JsonResult tokenAsJson ( final T authToken ) { final JsonObject jsonObject = new JsonObject ( ) ; jsonObject . put ( ""token"" , userAuth . tokenValue ( authToken ) ) ; return JsonResult . of ( jsonObject ) ; }",This function is converting the authentication token into JSON format and returning it as a JsonResult.,Prepares the JSON payload that carries on the token value .,Returns the JSONResult for the authentication token.
"public void setAsText ( String text ) { if ( text == null || text . equals ( """" ) ) { super . setValue ( new ComponentID [ 0 ] ) ; } else { java . util . ArrayList results = new java . util . ArrayList ( ) ; // the format for component ID is name vendor version. java . util . StringTokenizer st = new java . util . StringTokenizer ( text , CID_SEPARATOR , true ) ; ComponentIDPropertyEditor cidPropEditor = new ComponentIDPropertyEditor ( ) ; while ( st . hasMoreTokens ( ) ) { cidPropEditor . setAsText ( st . nextToken ( ) ) ; if ( st . hasMoreTokens ( ) ) { st . nextToken ( ) ; } results . add ( cidPropEditor . getValue ( ) ) ; } ComponentID [ ] cid = new ComponentID [ results . size ( ) ] ; results . toArray ( cid ) ; this . setValue ( cid ) ; } }","This function sets the text as a component ID, splits it by the specified separator and if the text is null or empty, it sets the value to a new ComponentID array.",Set the element as text value parse it and setValue . The separator is CID_SEPARATOR,Sets the text as a component ID.
public @ Nonnull DataRoot convert2DataRoot ( DataRootExt dataRootExt ) { DataRoot dataRoot = dataRootExt . getDataRoot ( ) ; if ( dataRoot != null ) return dataRoot ; // otherwise must read the catalog that its in dataRoot = readDataRootFromCatalog ( dataRootExt ) ; dataRootExt . setDataRoot ( dataRoot ) ; return dataRoot ; },"This function converts a DataRootExt object into a DataRoot object, either by directly accessing an existing DataRoot or reading it from a catalog if not already present.",convert a dataRootExt to a dataRoot,Converts a DataRootExt into sychronous dataRooter.
"public void versionControl ( ) throws DAVException { IResponse response = null ; try { response = davClient . versionControl ( locator , newContext ( ) , null ) ; examineResponse ( response ) ; } catch ( IOException e ) { throw new SystemException ( e ) ; } finally { closeResponse ( response ) ; } }",This function undertakes version control using a DAV client and handles any potential IO exceptions during the process.,Bring the receiver under version control . This means that the receiver is replaced by a version - controlled resource . Note that the client may send version control to a resource that is already under version control with no adverse effects .,This method is used to automate the DAV version control process.
protected static boolean hasCollectionsInDataSet ( HollowDataset dataset ) { for ( HollowSchema schema : dataset . getSchemas ( ) ) { if ( ( schema instanceof HollowListSchema ) || ( schema instanceof HollowSetSchema ) || ( schema instanceof HollowMapSchema ) ) { return true ; } } return false ; },"This function checks if the given HollowDataset contains any collections such as HollowListSchema, HollowSetSchema, or HollowMapSchema.",Determines whether DataSet contains any collections schema,Checks if the given HollowDataset contains any collections including HollowListSchema or HollowSetSchima.
"public static long checkStreamExists ( ClientConfiguration awsClientConfig , KinesisConfigBean conf , String streamName , List < Stage . ConfigIssue > issues , Stage . Context context ) { long numShards = 0 ; try { numShards = getShardCount ( awsClientConfig , conf , streamName ) ; } catch ( AmazonClientException | StageException e ) { LOG . error ( Errors . KINESIS_01 . getMessage ( ) , e . toString ( ) , e ) ; issues . add ( context . createConfigIssue ( Groups . KINESIS . name ( ) , KINESIS_CONFIG_BEAN + "".streamName"" , Errors . KINESIS_01 , e . toString ( ) ) ) ; } return numShards ; }","This function checks if a stream exists in AWS Kinesis, returning the number of shards the stream has; if an error is caught, it is logged and added to a list of issues.",Checks for existence of the requested stream and adds any configuration issues to the list .,Checks if a stream is present in Kinesis.
"protected void registerMadvocComponents ( ) { if ( madvocContainer == null ) { throw new MadvocException ( ""Madvoc WebApp not initialized."" ) ; } log . debug ( ""Registering Madvoc WebApp components"" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }","This function registers various Madvoc WebApp components to the MadvocContainer; if the MadvocContainer is not initialized, it throws a MadvocException.",Registers default Madvoc components .,register the MadvocContainer.
"public URLStreamHandler createURLStreamHandler ( final String protocol ) { // Check the handler map URLStreamHandler handler = ( URLStreamHandler ) handlerMap . get ( protocol ) ; if ( handler != null ) return handler ; // Validate that createURLStreamHandler is not recursing String prevProtocol = ( String ) createURLStreamHandlerProtocol . get ( ) ; if ( prevProtocol != null && prevProtocol . equals ( protocol ) ) return null ; createURLStreamHandlerProtocol . set ( protocol ) ; // See if the handler pkgs definition has changed checkHandlerPkgs ( ) ; // Search the handlerPkgs for a matching protocol handler ClassLoader ctxLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; for ( int p = 0 ; p < handlerPkgs . length ; p ++ ) { try { // Form the standard protocol handler class name String classname = handlerPkgs [ p ] + ""."" + protocol + "".Handler"" ; Class < ? > type = null ; try { type = ctxLoader . loadClass ( classname ) ; } catch ( ClassNotFoundException e ) { // Try our class loader type = Class . forName ( classname ) ; } if ( type != null ) { handler = ( URLStreamHandler ) type . newInstance ( ) ; handlerMap . put ( protocol , handler ) ; log . trace ( ""Found protocol:"" + protocol + "" handler:"" + handler ) ; } } catch ( Throwable ignore ) { } } createURLStreamHandlerProtocol . set ( null ) ; return handler ; }","This function creates a URLStreamHandler for a given protocol, searching the defined handler packages, and caches the handler for future use.",Search the handlerPkgs for URLStreamHandler classes matching the pkg + protocol + . Handler naming convention .,Create a URL stream handler.
"@ Override protected void sendData ( final OutputStream out ) throws IOException { if ( DEBUG ) { Log . v ( TAG , ""enter sendData(OutputStream)"" ) ; } out . write ( getContent ( ) ) ; }","This function overrides the sendData method, where it debug logs the entry into the method and writes the returned content from the getContent method to the OutputStream.",Writes the data to the given OutputStream .,This overrides the sendData instance.
"protected double grabDouble ( byte [ ] bytes , int offset ) throws DescriptorException { try { byte [ ] src ; if ( littleEndianData ) { src = new byte [ 8 ] ; src [ 0 ] = bytes [ offset + 7 ] ; src [ 1 ] = bytes [ offset + 6 ] ; src [ 2 ] = bytes [ offset + 5 ] ; src [ 3 ] = bytes [ offset + 4 ] ; src [ 4 ] = bytes [ offset + 3 ] ; src [ 5 ] = bytes [ offset + 2 ] ; src [ 6 ] = bytes [ offset + 1 ] ; src [ 7 ] = bytes [ offset ] ; offset = 0 ; } else { src = bytes ; } DataInputStream stream = new DataInputStream ( new ByteArrayInputStream ( src , offset , 8 ) ) ; return stream . readDouble ( ) ; } catch ( Exception ex ) { throw new DescriptorException ( ex ) ; } }","This function grabs and returns a 64-bit double precision floating point number from a given byte array, handling both little-endian and big-endian data.",Unpack an eight - byte IEEE float from the given byte array .,This method returns a 64 bit floating point number from the given byte array.
"private void checkDependencies ( SleeComponent sleeComponent , DeployableUnitImpl deployableUnit ) throws DependencyException { for ( ComponentID componentID : sleeComponent . getDependenciesSet ( ) ) { if ( componentID instanceof EventTypeID ) { if ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( EventTypeID ) componentID ) == null ) { throw new DependencyException ( ""Component "" + sleeComponent . getComponentID ( ) + "" depends on "" + componentID + "" which is not available in the component repository or in the deployable unit"" ) ; } } else if ( componentID instanceof LibraryID ) { if ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( LibraryID ) componentID ) == null ) { throw new DependencyException ( ""Component "" + sleeComponent . getComponentID ( ) + "" depends on "" + componentID + "" which is not available in the component repository or in the deployable unit"" ) ; } } else if ( componentID instanceof ProfileSpecificationID ) { if ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( ProfileSpecificationID ) componentID ) == null ) { throw new DependencyException ( ""Component "" + sleeComponent . getComponentID ( ) + "" depends on "" + componentID + "" which is not available in the component repository or in the deployable unit"" ) ; } } else if ( componentID instanceof ResourceAdaptorID ) { if ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( ResourceAdaptorID ) componentID ) == null ) { throw new DependencyException ( ""Component "" + sleeComponent . getComponentID ( ) + "" depends on "" + componentID + "" which is not available in the component repository or in the deployable unit"" ) ; } } else if ( componentID instanceof ResourceAdaptorTypeID ) { if ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( ResourceAdaptorTypeID ) componentID ) == null ) { throw new DependencyException ( ""Component "" + sleeComponent . getComponentID ( ) + "" depends on "" + componentID + "" which is not available in the component repository or in the deployable unit"" ) ; } } else if ( componentID instanceof SbbID ) { if ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( SbbID ) componentID ) == null ) { throw new DependencyException ( ""Component "" + sleeComponent . getComponentID ( ) + "" depends on "" + componentID + "" which is not available in the component repository or in the deployable unit"" ) ; } } else if ( componentID instanceof ServiceID ) { throw new SLEEException ( ""Component "" + sleeComponent . getComponentID ( ) + "" depends on a service component "" + componentID + "" which is not available in the component repository or in the deployable unit"" ) ; } } }","This function checks if dependencies of a given SLEE component exist within a specific deployable unit, and throws an exception if they do not.",Checks if all dependencies of a DU component exists,Checks if the given dependencies are present in the specified deployable unit.
"private < T > T getConfig ( final Class < T > configClass ) throws ConfigurationException { Iterator < Name > it = getServicePath ( ) . descendingPathIterator ( ) ; while ( it . hasNext ( ) ) { try ( InputStream in = getConfigurationStream ( configClass , it . next ( ) ) ) { return decoder . deserialise ( in , configClass ) ; } catch ( final ConfigurationException e ) { LOG . trace ( ""No configuration at this path level"" , e ) ; } catch ( final CodecException | IOException e ) { incrementErrors ( ) ; throw new ConfigurationException ( ""Failed to get configuration for "" + configClass . getSimpleName ( ) , e ) ; } } incrementErrors ( ) ; throw new ConfigurationException ( ""No configuration found for "" + configClass . getSimpleName ( ) ) ; }","This function retrieves a configuration of the specified class from a descending service path; it uses a decoder to deserialize the input stream from the configuration, handling exceptions for missing configurations and I/O errors.",Acquire decode and decrypt a configuration object from a data stream .,Returns the class that corresponds to the specified class configuration.
"@ Override public int getNodesWithStatus ( final Collection < String > iNodes , final String databaseName , final DB_STATUS ... statuses ) { for ( Iterator < String > it = iNodes . iterator ( ) ; it . hasNext ( ) ; ) { final String node = it . next ( ) ; if ( ! isNodeStatusEqualsTo ( node , databaseName , statuses ) ) it . remove ( ) ; } return iNodes . size ( ) ; }",This function overrides the getNodesWithStatus method to retrieve the total count of nodes matching the specified statuses from a given database and remove nodes not matching these statuses from the input collection.,Returns the nodes with the requested status .,Gets all of the nodes in the list matching statuses in this database.
"public Object execute ( final Map < Object , Object > iArgs ) { if ( type == null ) throw new OCommandExecutionException ( ""Cannot execute the command because it has not been parsed yet"" ) ; final ODatabaseDocument database = getDatabase ( ) ; final OClassEmbedded sourceClass = ( OClassEmbedded ) database . getMetadata ( ) . getSchema ( ) . getClass ( className ) ; if ( sourceClass == null ) throw new OCommandExecutionException ( ""Source class '"" + className + ""' not found"" ) ; OPropertyImpl prop = ( OPropertyImpl ) sourceClass . getProperty ( fieldName ) ; if ( prop != null ) { if ( ifNotExists ) { return sourceClass . properties ( ) . size ( ) ; } throw new OCommandExecutionException ( ""Property '"" + className + ""."" + fieldName + ""' already exists. Remove it before to retry."" ) ; } // CREATE THE PROPERTY OClass linkedClass = null ; OType linkedType = null ; if ( linked != null ) { // FIRST SEARCH BETWEEN CLASSES linkedClass = database . getMetadata ( ) . getSchema ( ) . getClass ( linked ) ; if ( linkedClass == null ) // NOT FOUND: SEARCH BETWEEN TYPES linkedType = OType . valueOf ( linked . toUpperCase ( Locale . ENGLISH ) ) ; } // CREATE IT LOCALLY OPropertyImpl internalProp = sourceClass . addPropertyInternal ( fieldName , type , linkedType , linkedClass , unsafe ) ; if ( readonly ) { internalProp . setReadonly ( true ) ; } if ( mandatory ) { internalProp . setMandatory ( true ) ; } if ( notnull ) { internalProp . setNotNull ( true ) ; } if ( max != null ) { internalProp . setMax ( max ) ; } if ( min != null ) { internalProp . setMin ( min ) ; } if ( defaultValue != null ) { internalProp . setDefaultValue ( defaultValue ) ; } return sourceClass . properties ( ) . size ( ) ; }","This function executes a command with provided arguments, checks if the command and source class exist, adjusts properties based on specified conditions, and returns the size of the properties of the source class.",Execute the CREATE PROPERTY .,Executes the given command.
"@ Override public Object invoke ( Object proxy , final Method method , final Object [ ] args ) throws Throwable { // If we setup a method handle earlier for this method, call it. // This is necessary for default methods that java8 creates, so we // can call the default method implementation (and not our proxied version of it). if ( methodHandleByMethod . containsKey ( method ) ) { return methodHandleByMethod . get ( method ) . invokeWithArguments ( args ) ; } if ( method . getDeclaringClass ( ) . equals ( Object . class ) ) { if ( ""equals"" . equals ( method . getName ( ) ) ) { return proxy == args [ 0 ] ; } else if ( ""hashCode"" . equals ( method . getName ( ) ) ) { return System . identityHashCode ( proxy ) ; } else { return method . invoke ( this , args ) ; } } AssistData data = assistDataByMethod . get ( method ) ; checkState ( data != null , ""No data for method: %s"" , method ) ; Provider < ? > provider ; if ( data . cachedBinding != null ) { // Try to get optimized form... provider = data . cachedBinding . getProvider ( ) ; } else { provider = getBindingFromNewInjector ( method , args , data ) . getProvider ( ) ; } try { int p = 0 ; for ( ThreadLocalProvider tlp : data . providers ) { tlp . set ( args [ p ++ ] ) ; } return provider . get ( ) ; } catch ( ProvisionException e ) { // if this is an exception declared by the factory method, throw it as-is if ( e . getErrorMessages ( ) . size ( ) == 1 ) { Message onlyError = getOnlyElement ( e . getErrorMessages ( ) ) ; Throwable cause = onlyError . getCause ( ) ; if ( cause != null && canRethrow ( method , cause ) ) { throw cause ; } } throw e ; } finally { for ( ThreadLocalProvider tlp : data . providers ) { tlp . remove ( ) ; } } }","This function implements the invocation of a method, handling default and Object class methods, checks method state, optimizes provider form, sets thread local providers, handles provision exceptions, and finally removes thread local providers.",When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .,Handle default and Object class methods. Method state ; provider form optimized!
"private void setFooterOfSheetConfiguration ( final FormCommand fcommand , final SheetConfiguration sheetConfig , final int leftCol , final int rightCol ) { String tempStr ; if ( fcommand . calcFooterLength ( ) == 0 ) { tempStr = CellUtility . getCellIndexLetterKey ( leftCol , 0 ) + "" : "" + CellUtility . getCellIndexLetterKey ( rightCol , 0 ) ; } else { tempStr = CellUtility . getCellIndexLetterKey ( leftCol , fcommand . getTopRow ( ) + fcommand . calcHeaderLength ( ) + fcommand . calcBodyLength ( ) ) + "" : "" + CellUtility . getCellIndexLetterKey ( rightCol , fcommand . getTopRow ( ) + fcommand . calcHeaderLength ( ) ) ; } sheetConfig . setFormFooterRange ( tempStr ) ; sheetConfig . setFooterCellRange ( new CellRange ( tempStr ) ) ; }",This function configures the footer of a sheet by setting the range of footer cells based on the given parameters.,Sets the footer of sheet configuration .,Set the footer range of footers.
"private static GroupType convertArrayType ( final String name , final ListTypeInfo typeInfo ) { final TypeInfo subType = typeInfo . getListElementTypeInfo ( ) ; return listWrapper ( name , listType ( ) , new GroupType ( Repetition . REPEATED , ParquetHiveSerDe . ARRAY . toString ( ) , convertType ( ""array_element"" , subType ) ) ) ; }","This function converts a given array type into a GroupType by taking the name and list type information, fetching the subType, and then invoking the listWrapper utility to construct a new GroupType.",1 anonymous element array_element,"Converts a Type into XML by modifying the specified array by using the given array. The method fetches the same Type as the provided array and then adds another Type to the Properties directory if necessary ; however, the only way to convert the Type is by default :"
"void emit_field ( int opcode , Type ctype , String name , Type ftype ) { mv . visitFieldInsn ( opcode , ctype . getInternalName ( ) , name , ftype . getDescriptor ( ) ) ; }","This function uses the MethodVisitor to emit a field instruction with information such as opcode, owning class internal name, field name, and field type descriptor.",package - protected for EmitUtils try to fix,Method to fetch method instruction.
"public boolean addVertex ( Vertex < T > v ) { if ( verticies . containsValue ( v ) == false ) { verticies . put ( v . getName ( ) , v ) ; return true ; } return false ; }","This function adds a new vertex to the vertices map if it does not already exist, returning true if successful and false otherwise.",Add a vertex to the graph,Adds a new vertex to the existing vertika.
"public static boolean isEmpty ( final Name name ) { return name . isEmpty ( ) || ( name . size ( ) == 1 && """" . equals ( name . get ( 0 ) ) ) ; }",This function checks if the given name is empty or only contains an empty string.,Determine if a name is empty or if ot contains only one component which is the empty string .,Checks if the name is empty or a contains empty string.
private static boolean hasScope ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation annotation : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) ) { return true ; } } return false ; },This function checks if the given interceptor class contains annotations that are identified as scope annotations.,Returns true if the given class has a scope annotation .,Checks if an annotation has been identified as scope annotations in an interceptor class.
public int getIndexOf ( Object key ) { // Get the index from the map Integer index = keyToIndex . get ( key ) ; // Check that the key is in the map and return -1 if it is not. if ( index == null ) { return - 1 ; } return index ; },This function retrieves the index of a given key from a map; returns -1 if the key does not exist in the map.,Returns the index to which this map maps the specified key .,Returns the index of the given key from the map.
"public static Filter logResponseToIfMatches ( PrintStream stream , Matcher < Integer > matcher ) { return new ResponseLoggingFilter ( stream , matcher ) ; }","This function creates and returns a new ResponseLoggingFilter object, logging the responses to the provided printStream if they match with the specific matcher criteria.",Create a new logging filter without using the new operator . Will make the DSL look nicer .,Log the responses to the provided stream if they match the given matcher criteria.
"public < T > T deserialize ( File file , TypeRef returnType ) throws ApiException { JavaType javaType = mapper . constructType ( returnType . getType ( ) ) ; try { return mapper . readValue ( file , javaType ) ; } catch ( IOException e ) { throw new ApiException ( 500 , e . getMessage ( ) , null , ""File to read file"" ) ; } }","This function deserializes a file into a specified return type, throwing an ApiException if the file cannot be read.",Deserialize the given File to Java object .,File deserialize as file enterr.
"public GeometryMetadata populate ( long geoPackageId , String tableName , long geomId , GeometryEnvelope envelope ) { GeometryMetadata metadata = new GeometryMetadata ( ) ; metadata . setGeoPackageId ( geoPackageId ) ; metadata . setTableName ( tableName ) ; metadata . setId ( geomId ) ; metadata . setMinX ( envelope . getMinX ( ) ) ; metadata . setMaxX ( envelope . getMaxX ( ) ) ; metadata . setMinY ( envelope . getMinY ( ) ) ; metadata . setMaxY ( envelope . getMaxY ( ) ) ; if ( envelope . hasZ ( ) ) { metadata . setMinZ ( envelope . getMinZ ( ) ) ; metadata . setMaxZ ( envelope . getMaxZ ( ) ) ; } if ( envelope . hasM ( ) ) { metadata . setMinM ( envelope . getMinM ( ) ) ; metadata . setMaxM ( envelope . getMaxM ( ) ) ; } return metadata ; }",This function populates a GeometryMetadata object with data from a given geopackage and returns it.,Populate a new geometry metadata from an envelope,Populates an object from a geopackage.
protected Collection < T > convertToSingleElementCollection ( final Object value ) { Collection < T > collection = createCollection ( 0 ) ; //noinspection unchecked collection . add ( ( T ) value ) ; return collection ; },This function converts a single object into a collection of that single element.,Creates a collection with single element .,Converts an object into a collection of elements that is unique to the object object used in the constructor.
"public void commit ( String offset ) { batchCommitted = true ; LOG . trace ( ""Last committed offset '{}', attempting to commit '{}'"" , lastCommittedOffset , offset ) ; Utils . checkState ( null != lastCommittedOffset , ""Last committed offset cannot be null"" ) ; controlChannel . consumerCommit ( offset ) ; lastCommittedOffset = offset ; }","This function commits a new offset, logs the action, validates that the last committed offset is not null, and updates the last committed offset value.",Commit the offset . Required after take has returned a non - null value .,commit a new offset.
"private void doAdditionalRead ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } } }","This function performs additional reading from a WebSocket connection, handling any potential InterruptedExceptions or IOexceptions, and ensuring backpressure is managed by queuing incoming data and properly handling buffers.",Do an additional read,Reads a packet from sychronous network.
"public void fireAddOrUpdatedEventIfNeeded ( ) { if ( state == ProfileObjectState . READY ) { if ( profileEntity . isDirty ( ) ) { // check the table fires events and the object is not assigned to a default profile if ( profileTable . doesFireEvents ( ) && profileEntity . getProfileName ( ) != null && profileTable . getSleeContainer ( ) . getSleeState ( ) == SleeState . RUNNING ) { // Fire a Profile Added or Updated Event ActivityContext ac = profileTable . getActivityContext ( ) ; AbstractProfileEvent event = null ; if ( profileEntity . isCreate ( ) ) { if ( persisted ) { event = new ProfileAddedEventImpl ( profileEntity , profileTable . getProfileManagement ( ) ) ; persisted = false ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( ""firing profile added event for profile named "" + profileEntity ) ; } } else { return ; } } else { event = new ProfileUpdatedEventImpl ( profileEntitySnapshot , profileEntity , profileTable . getProfileManagement ( ) ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( ""firing profile updated event for profile named "" + profileEntity ) ; } } ac . fireEvent ( event . getEventTypeID ( ) , event , event . getProfileAddress ( ) , null , null , null , null ) ; } } } }","Fires a 'Profile Added' or 'Profile Updated' event if the profile object is dirty, not designated to a default profile, and the SLEE container is running.",Fires a profile added or updated event if the profile object state is ready and the persistent state is dirty,Fire a Fire event regarding the profile inclusion in the default profile.
"public int findIdx ( int want ) { if ( isConstant ) return ( want == start ) ? 0 : - 1 ; if ( isSequential ) return want - start ; if ( isSorted ) { return Arrays . binarySearch ( raw , want ) ; } // linear search for ( int i = 0 ; i < raw . length ; i ++ ) if ( raw [ i ] == want ) return i ; return - 1 ; }","This function finds the index of a specified value in a data set, using different search strategies based on the properties of the data set (constant, sequential, sorted, or else it defaults to a linear search).",Find which index holds the value want,Finds the value in the index of the given set.
"boolean pushVariableReference ( String name ) { if ( ! isParserTranslationEnabled ( ) ) { return push ( new SimpleNode ( name ) ) ; } // Walk down the stack, looking for a scope node that knows about a given variable for ( Node node : getContext ( ) . getValueStack ( ) ) { if ( ! ( node instanceof ScopeNode ) ) { continue ; } // Ensure that the variable exists ScopeNode scope = ( ScopeNode ) node ; if ( ! scope . isVariableDefined ( name ) ) { continue ; } return push ( new VariableReferenceNode ( name ) ) ; } // Record error location throw new UndefinedVariableException ( name ) ; }","This function pushes a new VariableReferenceNode for a given variable 'name' onto the stack if the variable is defined in the current scope and parsing translation is enabled, otherwise, it throws an UndefinedVariableException.",Looks for a variable definition that matches the reference in the scope nodes on the stack . If found a reference node that can repeat this lookup later is placed on the stack not the current value itself . This is done because the value may change if the variable reference is inside a mixin .,Pushes a variable.
"int addConstantNameAndType ( final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int hashCode = hash ( tag , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry . index ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , name , descriptor , hashCode ) ) . index ; }","This function adds a constant name and type symbol to the constant pool with a specific name and descriptor, returning the index of the symbol in the constant pool.",Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .,Adds the constant pool of symbol to the pool.
"int readTop ( ucar . unidata . io . RandomAccessFile raf ) throws IOException { int pos = 0 ; // long     actualSize = 0; raf . seek ( pos ) ; int readLen = 35 ; // Read in the contents of the NEXRAD Level III product head byte [ ] b = new byte [ readLen ] ; int rc = raf . read ( b ) ; if ( rc != readLen ) { return 0 ; } // check if ( ( convertunsignedByte2Short ( b [ 0 ] ) != 0x00 ) || ( convertunsignedByte2Short ( b [ 1 ] ) != 0xF0 ) || ( convertunsignedByte2Short ( b [ 2 ] ) != 0x09 ) ) { return 0 ; } String pidd = new String ( b , 15 , 5 , CDM . utf8Charset ) ; if ( pidd . contains ( ""NOWRA"" ) || pidd . contains ( ""USRAD"" ) || pidd . contains ( ""NEX"" ) ) { return 1 ; } else { return 0 ; } }","This function reads the top of a given random access file, checking for specific header identifiers before determining whether or not it contains certain strings and returning a corresponding integer value.",read the header of input file and parsing the NOWRAD part,Reads the top line of the index file.
"public static byte [ ] decode ( String input ) throws IllegalArgumentException { if ( input . startsWith ( ""base58:"" ) ) input = input . substring ( 7 ) ; if ( input . length ( ) == 0 ) return new byte [ 0 ] ; // Convert the base58-encoded ASCII chars to a base58 byte sequence (base58 digits). byte [ ] input58 = new byte [ input . length ( ) ] ; for ( int i = 0 ; i < input . length ( ) ; ++ i ) { char c = input . charAt ( i ) ; int digit = c < 128 ? INDEXES [ c ] : - 1 ; if ( digit < 0 ) { throw new IllegalArgumentException ( ""Illegal character "" + c + "" at position "" + i ) ; } input58 [ i ] = ( byte ) digit ; } // Count leading zeros. int zeros = 0 ; while ( zeros < input58 . length && input58 [ zeros ] == 0 ) { ++ zeros ; } // Convert base-58 digits to base-256 digits. byte [ ] decoded = new byte [ input . length ( ) ] ; int outputStart = decoded . length ; for ( int inputStart = zeros ; inputStart < input58 . length ; ) { decoded [ -- outputStart ] = divmod ( input58 , inputStart , 58 , 256 ) ; if ( input58 [ inputStart ] == 0 ) { ++ inputStart ; // optimization - skip leading zeros } } // Ignore extra leading zeroes that were added during the calculation. while ( outputStart < decoded . length && decoded [ outputStart ] == 0 ) { ++ outputStart ; } // Return decoded data (including original number of leading zeros). return Arrays . copyOfRange ( decoded , outputStart - zeros , decoded . length ) ; }","This function decodes a base58-encoded string into a byte array, throwing an IllegalArgumentException if the input string contains any illegal characters.",Decodes the given base58 string into the original data bytes .,Decode a base58 encoded string into byte array.
"public String getPrincipal ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { log . warn ( ""No Authentication object set in SecurityContext - returning empty String as Principal"" ) ; return """" ; } Object principal = authentication . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) principal ; return details . getDn ( ) ; } else if ( authentication instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( ""Anonymous Authentication, returning empty String as Principal"" ) ; } return """" ; } else { throw new IllegalArgumentException ( ""The principal property of the authentication object"" + ""needs to be an LdapUserDetails."" ) ; } }","This function retrieves the principal (authenticated user) from the security context, and if it is an LDAP user it returns the distinguished name; if it is an anonymous user, it returns an empty string; if neither, it throws an error.",Get the principals of the logged in user in this case the distinguished name .,Returns the Authenticated User.
private String generateTokenString ( ) throws Exception { //Renew age //Stringify token data StringBuilder dataString = new StringBuilder ( ) ; dataString . append ( getUserId ( ) ) . append ( SEPARATOR ) . append ( getUsername ( ) ) . append ( SEPARATOR ) . append ( getExpirationDate ( ) . getTime ( ) ) . append ( SEPARATOR ) . append ( attributesHash ) ; // Encrypt token data string String newTokenString = encryptor . encrypt ( dataString . toString ( ) ) ; newTokenString = BaseEncoding . base16 ( ) . encode ( newTokenString . getBytes ( ) ) ; tokenString = newTokenString ; return newTokenString ; },"This function generates a new token string, which concatenates user ID, username, expiration date and attributes hash, encrypts this data and encodes it to base16.",Generates a tokenString with a new expiration date and assigns it .,Generate a token token
"public static String [ ] getStrings ( String str , String delim ) { Collection < String > values = getStringCollection ( str , delim ) ; if ( values . size ( ) == 0 ) { return null ; } return values . toArray ( new String [ values . size ( ) ] ) ; }","This function divides a given string ""str"" into a string array based on a specified delimiter ""delim"", by utilizing the getStringCollection method.",Returns an arraylist of strings .,This method attempts to divide a string into str.
public static ForwardPath of ( Path path ) { ForwardPath next = new ForwardPath ( path ) ; if ( path . getPrevious ( ) == Path . root ( ) ) return next ; ForwardPath previous = of ( path . getPrevious ( ) ) ; previous . next = next ; return previous ; },"This function recursively creates a forward path from a given path until it reaches the root, and connects all the created forward paths.",Recursive method which reverses the path into a ForwardPath .,Creates a forward path from the given path.
"@ Generated ( value = ""com.sun.tools.xjc.Driver"" , date = ""2018-10-12T02:50:55+02:00"" , comments = ""JAXB RI v2.2.11"" ) public void setZimmertyp ( Zimmer . Zimmertyp value ) { this . zimmertyp = value ; }","This function sets the room type (Zimmertyp) for a room object, generated by JAXB RI v2.2.11 on 2018-10-12.",Sets the value of the zimmertyp property .,Sets the Zimmertyp for the object.
"public ILocator newLocator ( String resourceURL , String label ) { return locatorFactory . newLocator ( resourceURL , label ) ; }",This function creates a new locator object by calling the newLocator method of the locatorFactory with a given resourceURL and label as parameters.,Answer a new resource locator that identifies a particular server resource by it s URL and label .,Create a new locator for the specified resource URL and label.
"public static String getStackTrace ( Thread t ) { final StackTraceElement [ ] stackTrace = t . getStackTrace ( ) ; StringBuilder str = new StringBuilder ( ) ; for ( StackTraceElement e : stackTrace ) { str . append ( e . toString ( ) + ""\n"" ) ; } return str . toString ( ) ; }",This function retrieves and returns the stack trace of a specific thread as a string.,Get stack trace for a given thread .,Returns the trace of the thread in the string.
"private Date getBuildReferenceDate ( ) throws MojoExecutionException { // Pick up an existing build date created by fabric8:build previously File tsFile = new File ( project . getBuild ( ) . getDirectory ( ) , AbstractDockerMojo . DOCKER_BUILD_TIMESTAMP ) ; if ( ! tsFile . exists ( ) ) { return new Date ( ) ; } try { return EnvUtil . loadTimestamp ( tsFile ) ; } catch ( IOException e ) { throw new MojoExecutionException ( ""Cannot read timestamp from "" + tsFile , e ) ; } }","This function retrieves the reference build date from a file, resorting to generate a new Date object if the file doesn't exist, and handles any exceptions that occur during this process.",get a reference date,This method initializes the date for the reference build date in the file. If the current date is not present it will be returned if the references are not created ; and a subsequent date will have no effect on the existing date - date
"public Object newBeanInstance ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( ""No constructor (annotated, single or default) founded as injection point for: "" + beanDefinition . type . getName ( ) ) ; } int paramNo = beanDefinition . ctor . references . length ; Object [ ] args = new Object [ paramNo ] ; // wiring if ( beanDefinition . wiringMode != WiringMode . NONE ) { for ( int i = 0 ; i < paramNo ; i ++ ) { args [ i ] = pc . getBean ( beanDefinition . ctor . references [ i ] ) ; if ( args [ i ] == null ) { if ( ( beanDefinition . wiringMode == WiringMode . STRICT ) ) { throw new PetiteException ( ""Wiring constructor failed. References '"" + beanDefinition . ctor . references [ i ] + ""' not found for constructor: "" + beanDefinition . ctor . constructor ) ; } } } } // create instance final Object bean ; try { bean = beanDefinition . ctor . constructor . newInstance ( args ) ; } catch ( Exception ex ) { throw new PetiteException ( ""Failed to create new bean instance '"" + beanDefinition . type . getName ( ) + ""' using constructor: "" + beanDefinition . ctor . constructor , ex ) ; } return bean ; }","This function creates a new instance of a Bean based on the provided definition, while also handling constructor parameters and throwing errors if needed.",Creates a new instance .,Create a new instance of sanitizer based on defined definition.
"private static Set < ORecord > mergeSet ( Set < ORecord > target , Set < ORecord > source ) { if ( source != null ) { if ( target == null ) { return source ; } else { if ( target . size ( ) > source . size ( ) ) { target . addAll ( source ) ; return target ; } else { source . addAll ( target ) ; return source ; } } } else { return target ; } }","Merges two sets of ORecord objects, favoring the larger set for efficiency, and handles null cases.",Merge the two set try to use the optimum case,Merge deux sets of ORecord objects.
"private void readParameters ( final OContextConfiguration iServerConfig , final OServerParameterConfiguration [ ] iParameters ) { configuration = new OContextConfiguration ( iServerConfig ) ; // SET PARAMETERS if ( iParameters != null && iParameters . length > 0 ) { // CONVERT PARAMETERS IN MAP TO INTIALIZE THE CONTEXT-CONFIGURATION for ( OServerParameterConfiguration param : iParameters ) configuration . setValue ( param . name , param . value ) ; } socketBufferSize = configuration . getValueAsInteger ( OGlobalConfiguration . NETWORK_SOCKET_BUFFER_SIZE ) ; }","This function initializes the context configuration by reading server configuration and parameters, and also sets the socket buffer size.",Initializes connection parameters by the reading XML configuration . If not specified get the parameters defined as global configuration .,Initializes the configuration in the specified context. The parameter s read configuration and the socket - buffer
"public OrientGraph getTx ( ) { final OrientGraph g ; if ( pool == null ) { g = ( OrientGraph ) getTxGraphImplFactory ( ) . getGraph ( getDatabase ( ) , user , password , settings ) ; } else { // USE THE POOL g = ( OrientGraph ) getTxGraphImplFactory ( ) . getGraph ( pool , settings ) ; } initGraph ( g ) ; return g ; }","This function retrieves OrientGraph instance using either a database or pool, depending on whether the pool is null or not, and initializes the graph before returning it.",Gets transactional graph with the database from pool if pool is configured . Otherwise creates a graph with new db instance . The Graph instance inherits the factory s configuration .,Returns the OrientGraph instance.
"private void invokePlugin ( Node . CustomTag n ) { TagPlugin tagPlugin = tagPlugins . get ( n . getTagHandlerClass ( ) . getName ( ) ) ; if ( tagPlugin == null ) { return ; } TagPluginContext tagPluginContext = new TagPluginContextImpl ( n , pageInfo ) ; n . setTagPluginContext ( tagPluginContext ) ; tagPlugin . doTag ( tagPluginContext ) ; }",This function retrieves a specific TagPlugin based on a node's handler class name and then uses this plugin to process the given node.,Invoke tag plugin for the given custom tag if a plugin exists for the custom tag s tag handler .,Returns a TagPlugin based on the handler class name used by the specified node.
"protected static void writeInputStreamToOutput ( final Context context , final InputStream source , final OutputStream output ) throws IOException { BuffersPool pool = BeansManager . get ( context ) . getContainer ( ) . getBean ( BuffersPool . class ) ; IoUtils . transfer ( source , output , pool ) ; }","This function writes the contents of an input stream to an output stream using a buffer pool from the application context, throwing an IOException if an input or output error occurs.",Utility method for transferring input stream to output .,Write a buffer from an input stream to an output stream.
public void setPresence ( boolean present ) { if ( this . present == present ) return ; this . present = present ; updateVague ( ) ; if ( present ) { firePresence ( true ) ; } else { fireLeaving ( ) ; } },This function updates the presence status of a user and triggers corresponding events.,sets the presence,Updates the presence of the user.
"private static void setCellValueNumber ( final Cell c , final String value ) { double val = Double . parseDouble ( value . replace ( Character . toString ( ' ' ) , """" ) ) ; c . setCellType ( CellType . NUMERIC ) ; c . setCellValue ( val ) ; }","This function removes any spaces from the given string, converts it into a double, sets the cell type as numeric and then sets this numeric value to the specified cell.",Sets the cell value number .,Remove any spaces from the string.
"protected void cacheResultSetEntities ( final Object [ ] result ) { if ( entitiesCache == null ) { entitiesCache = new HashMap <> ( ) ; } for ( int i = 0 ; i < result . length ; i ++ ) { Object object = result [ i ] ; if ( object == null ) { continue ; } DbEntityDescriptor ded = cachedDbEntityDescriptors [ i ] ; if ( ded == null ) { // not a type, continue continue ; } // calculate key Object key ; if ( ded . hasIdColumn ( ) ) { //noinspection unchecked key = ded . getKeyValue ( object ) ; } else { key = object ; } Object cachedObject = entitiesCache . get ( key ) ; if ( cachedObject == null ) { // object is not in the cache, add it entitiesCache . put ( key , object ) ; } else { // object is in the cache, replace it result [ i ] = cachedObject ; } } }","This function caches entities from a result set, retrieves existing cached entities based on keys, and replaces entities in the result array with the cached entities if they exist in the cache.",Caches returned entities . Replaces new instances with existing ones .,Cache entities from a result set.
"private int calcNumberOfColumns ( ) { int result = 0 ; if ( fields != null ) { Iterator < FieldEditor > e = fields . iterator ( ) ; while ( e . hasNext ( ) ) { FieldEditor pe = e . next ( ) ; result = Math . max ( result , pe . getNumberOfControls ( ) ) ; } } return result ; }","This function calculates and returns the maximum number of controls across all fields, if the fields are not null.",Calculates the number of columns needed to host all field editors .,Calculate the maximum number of controls across all fields.
public static String parseRemoteIP ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; },"This function retrieves and returns the remote IP address from a given channel, if the channel is not null; returns an empty string otherwise.",Parse the remote host ip of the channel .,This method returns the remote IP address of the given channel. If the IP addresses are not null then the method will be returned if the host is empty ; and the operator will return the returned address - address otherwise a false address is returned
"private synchronized File ensureWorkingDirectory ( ) throws IOException { File directory = getWorkingDirectory ( ) ; if ( ! directory . exists ( ) ) { if ( ! directory . mkdirs ( ) ) { throw new IOException ( ""Working directory "" + directory + "" cannot be created"" ) ; } } else { if ( ! directory . isDirectory ( ) ) { if ( ! directory . delete ( ) ) { throw new IOException ( directory + "" is not a directory and cannot be deleted"" ) ; } if ( ! directory . mkdirs ( ) ) { throw new IOException ( ""Working directory "" + directory + "" cannot be recreated"" ) ; } } } return directory ; }","This function ensures the working directory exists, creates it if not, or deletes and recreates it if it's not a directory, synchronizing the process to prevent concurrent modification and throwing an IOException if any step fails.",this method is synchronized in order to avoid concurrent calls to mkdir,Create and recreate a directory.
public boolean hasEdge ( Edge < T > e ) { if ( e . getFrom ( ) == this ) return outgoingEdges . contains ( e ) ; else if ( e . getTo ( ) == this ) return incomingEdges . contains ( e ) ; else return false ; },This function checks if a specified edge is either originating from or leading to this node by examining the outgoing and incoming edges respectively.,Check the vertex for either an incoming or outgoing edge mathcing e .,Checks if this node is a trace from or leads to the given nodes.
"protected void addPropertyInjectionPoint ( final PropertyInjectionPoint pip ) { if ( properties == null ) { properties = new PropertyInjectionPoint [ 1 ] ; properties [ 0 ] = pip ; } else { properties = ArraysUtil . append ( properties , pip ) ; } }","This function adds a new PropertyInjectionPoint to the properties array, initializing the array if it's null.",Adds property injection point .,Adds a new object to this property array.
"public static int hashTableSize ( int numElements ) throws IllegalArgumentException { if ( numElements < 0 ) { throw new IllegalArgumentException ( ""cannot be negative; numElements="" + numElements ) ; } else if ( numElements > HASH_TABLE_MAX_SIZE ) { throw new IllegalArgumentException ( ""exceeds maximum number of buckets; numElements="" + numElements ) ; } if ( numElements == 0 ) return 1 ; if ( numElements < 3 ) return numElements * 2 ; // Apply load factor to number of elements and determine next // largest power of 2 that fits in an int int sizeAfterLoadFactor = ( int ) ( ( long ) numElements * 10 / 7 ) ; int bits = 32 - Integer . numberOfLeadingZeros ( sizeAfterLoadFactor - 1 ) ; return 1 << bits ; }","This function calculates the size of a hash table given a number of elements; it applies load factor, ensures the value is not negative, does not exceed maximum size, and returns the next largest power of 2 size.",Determine size of hash table capable of storing the specified number of elements with a load factor applied .,Calculates the number of pieces in a row. The count is 1 - 5 % and the count of 2!
void addParentJoin ( Cursor cursor ) throws IOException { int level = cursor . currentIndex ; Table t = getTable ( level ) ; if ( t . extraJoins != null ) { List < StructureData > sdata = new ArrayList <> ( 3 ) ; sdata . add ( cursor . tableData [ level ] ) ; for ( Join j : t . extraJoins ) { sdata . add ( j . getJoinData ( cursor ) ) ; } cursor . tableData [ level ] = StructureDataFactory . make ( sdata . toArray ( new StructureData [ sdata . size ( ) ] ) ) ; // LOOK should try to consolidate } },"This function adds a parent join to a cursor, checks for extra joins in the table at the current index level, and updates the table data with the join data if there are any extra joins.",add table join to this cursor level,Adds a parent join to the cursor.
"static String getActiveMQServerName ( Map < String , String > properties ) { return properties . getOrDefault ( SERVER , DEFAULT ) ; }","This function returns the name of the ActiveMQ server from the given properties map, or returns a default value if the server name is not found.",The JMS connection factory can specify another server to deploy its destinations by passing a property server = &lt ; name of the server > . Otherwise default is used by default .,Returns the name of the ActiveMQ Server.
"protected void createArrayProperties ( ) { // Scan through all defined properties. for ( Object o : keySet ( ) ) { String key = ( String ) o ; String value = super . getProperty ( key ) ; // Split the property key into everything before the last '.' and after it. int lastDotIndex = key . lastIndexOf ( ' ' ) ; String keyEnding = key . substring ( lastDotIndex + 1 , key . length ( ) ) ; String keyStart = key . substring ( 0 , ( lastDotIndex == - 1 ) ? 0 : lastDotIndex ) ; // Check if the property key ends in an integer, in which case it is an array property. int index = 0 ; try { index = Integer . parseInt ( keyEnding ) ; } catch ( NumberFormatException e ) { // The ending is not an integer so its not an array. // Exception can be ignored as it means this property is not an array. e = null ; continue ; } // Check if an array property already exists for this base name and create one if not. ArrayList propArray = ( ArrayList ) arrayProperties . get ( keyStart ) ; if ( propArray == null ) { propArray = new ArrayList ( ) ; arrayProperties . put ( keyStart , propArray ) ; } // Add the new property value to the array property for the index. propArray . set ( index , value ) ; } }","This function parses properties from a keyset, checks for array properties by identifying keys ending with an integer, and then creates new array properties or adds to existing ones as needed.",Scans all the properties in the parent Properties object and creates arrays for any array property definitions .,Parses the properties of a keyset to the specified properties. The properties are added to each element of the array before they are parsed - and each property is individually mapped  means that each attribute of this array is different than the elemental properties specified in the list corresponding to that element ; and every element in this list is equal to another element
private DataType getCoordinateType ( ) { List < Dataset > nestedDatasets = getDatasets ( ) ; DatasetOuterDimension first = ( DatasetOuterDimension ) nestedDatasets . get ( 0 ) ; return first . isStringValued ? DataType . STRING : DataType . DOUBLE ; },"This function gets the data type of the first coordinate in the nested datasets, returning STRING if it's string valued and DOUBLE if not.",What is the data type of the aggregation coordinate ?,Returns the value of the given coordinate object as the coordinate type.
"@ SneakyThrows public static com . google . cloud . datastore . Key fromUrlSafe ( final String urlSafeKey ) { if ( urlSafeKey . startsWith ( ""a"" ) ) { return KeyFormat . INSTANCE . parseOldStyleAppEngineKey ( urlSafeKey ) ; } else { return com . google . cloud . datastore . Key . fromUrlSafe ( urlSafeKey ) ; } }","This function converts a URL-safe string into a Google Cloud Datastore Key, with the added condition to parse old style App Engine keys if the string begins with 'a'.",Understands both the legacy format ag1zfnZvb2Rvb2R5bmUwcgcLEgFCGAEM and new format providing the key either way .,Converts the given URL to Google Cloud Datastore.
"private void convertMemberInfo ( StructureMembers wrapperSm ) { for ( StructureMembers . Member m : wrapperSm . getMembers ( ) ) { Variable v = findVariable ( m . getName ( ) ) ; if ( ( v == null ) && ( orgVar != null ) ) // may have been renamed v = ( Variable ) findVariableFromOrgName ( m . getName ( ) ) ; if ( v != null ) { // a section will have missing variables LOOK wrapperSm probably wrong in that case //  log.error(""Cant find "" + m.getName()); //else m . setVariableInfo ( v . getShortName ( ) , v . getDescription ( ) , v . getUnitsString ( ) , v . getDataType ( ) ) ; } // nested structures if ( v instanceof StructureDS ) { StructureDS innerStruct = ( StructureDS ) v ; innerStruct . convertMemberInfo ( m . getStructureMembers ( ) ) ; } } }","This function converts information of members within a structure, handles missing variables, and recursively handles inner substructures.",the wrapper StructureMembers must be converted to correspond to the wrapper Structure,Returns the members in the structure.
public static MultiTypeData getMultiTypeData ( boolean b ) { // Convert the value to a String and return the set of types that that String can be converted to. MultiTypeData result = getMultiTypeData ( Boolean . toString ( b ) ) ; result . nativeType = BOOLEAN ; return result ; },"This function converts a boolean to a string and returns the corresponding MultiTypeData object, while setting its native type to BOOLEAN.",Converts a boolean into a multi type data object .,Returns the MultiTypeData object corresponding to the given boolean.
protected String lookupAlias ( final String alias ) { String value = actionsManager . lookupPathAlias ( alias ) ; if ( value == null ) { ActionRuntime cfg = actionsManager . lookup ( alias ) ; if ( cfg != null ) { value = cfg . getActionPath ( ) ; } } return value ; },This function returns the path alias for a given alias or the action path if the alias doesn't exist in the actionsManager.,Lookups value as an alias and if not found as a default alias .,This method returns the path alias for an id set or the action path for the given alis.
"public static void applyDefaultHeader ( final UnsafeBuffer metadataBuffer , final UnsafeBuffer termBuffer , final int termOffset ) { termBuffer . putBytes ( termOffset , metadataBuffer , LOG_DEFAULT_FRAME_HEADER_OFFSET , HEADER_LENGTH ) ; }",This function applies the default header to the term buffer at the specified offset using data from the metadata buffer.,Apply the default header for a message in a term .,default header to term buffer default value
"public List < V > getAll ( final String name ) { LinkedList < V > values = new LinkedList <> ( ) ; int h = hash ( name ) ; int i = index ( h ) ; MapEntry < V > e = entries [ i ] ; while ( e != null ) { if ( e . hash == h && eq ( name , e . key ) ) { values . addFirst ( e . getValue ( ) ) ; } e = e . next ; } return values ; }","This function retrieves all values associated with a given key from a hashmap, returning them in a LinkedList.",Returns all values associated with the name .,Returns values associated with the given key as a result.
@ Subscribe public void handle ( ElementEvent < TEntity > message ) { if ( message . getEndpoint ( ) . getEntityType ( ) == this . endpoint . getEntityType ( ) ) { refresh ( ) ; } },"This function subscribes to an ElementEvent of type TEntity, and refreshes the endpoint if the entity type of the received message matches with the entity type of its own endpoint.",Refresh when child elements are created or updated,This method refreshes the endpoint if the entity type is compatible with the given entity.
"public void extractMetaTags ( DocumentFragment doc ) throws XPathExpressionException { NodeList nodes = ( NodeList ) expression . evaluate ( doc , XPathConstants . NODESET ) ; if ( nodes == null ) return ; int numNodes = nodes . getLength ( ) ; for ( int i = 0 ; i < numNodes ; i ++ ) { Node n = ( Node ) nodes . item ( i ) ; // iterate on the attributes // and check that it has name=robots and content // whatever the case is boolean isRobots = false ; String content = null ; NamedNodeMap attrs = n . getAttributes ( ) ; for ( int att = 0 ; att < attrs . getLength ( ) ; att ++ ) { Node keyval = attrs . item ( att ) ; if ( ""name"" . equalsIgnoreCase ( keyval . getNodeName ( ) ) && ""robots"" . equalsIgnoreCase ( keyval . getNodeValue ( ) ) ) { isRobots = true ; continue ; } if ( ""content"" . equalsIgnoreCase ( keyval . getNodeName ( ) ) ) { content = keyval . getNodeValue ( ) ; continue ; } } if ( isRobots && content != null ) { // got a value - split it String [ ] vals = content . split ( "" *, *"" ) ; parseValues ( vals ) ; return ; } } }","This function extracts meta tag information (particularly, name and content attributes) from a document fragment and handles robots meta tag by splitting the content and parsing the values when both ""robots"" and content found.",called by the parser bolts,Translated meta tag information into a fragment.
"public static < E > Queue < E > getTransactionalQueue ( java . util . Queue < E > queue ) { return new WrapperQueue < E > ( queue , new LinkedList < E > ( ) , true , false , false ) ; }",This function creates a new transactional queue by wrapping the given queue with certain properties such as retention in a linked list and boolean values indicating its functionality.,Provides a transactional queue that delays all queue manipulation operations until the transaction is committed or erases them if it is rolled back .,Create a new transactional queue.
"@ Generated ( value = ""com.sun.tools.xjc.Driver"" , date = ""2018-10-12T02:42:33+02:00"" , comments = ""JAXB RI v2.2.11"" ) public List < ValueListsType . VALUELIST > getVALUELIST ( ) { if ( valuelist == null ) { valuelist = new ArrayList < ValueListsType . VALUELIST > ( ) ; } return this . valuelist ; }","This function retrieves the list of VALUELIST from the ValueListsType, initializes it if it's null, and was generated by JAXB RI v2.2.11.",Gets the value of the valuelist property .,Get the VALUELISTs list.
"public void restoreAllTablesFromCsv ( Context ctx , SQLiteDatabase db , String suffix ) { for ( TableHelper table : getTableHelpers ( ) ) { table . restore ( db , ctx , suffix ) ; } }","This function restores all tables from a CSV file by calling the restore method for each table helper in the context and database specified, appending a provided suffix.",Restore all tables from CSV files one per table,restore all tables from a file.
"public FSList getOccurrences ( ) { if ( CandidateAnswerVariant_Type . featOkTst && ( ( CandidateAnswerVariant_Type ) jcasType ) . casFeat_occurrences == null ) jcasType . jcas . throwFeatMissing ( ""occurrences"" , ""edu.cmu.lti.oaqa.type.answer.CandidateAnswerVariant"" ) ; return ( FSList ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( CandidateAnswerVariant_Type ) jcasType ) . casFeatCode_occurrences ) ) ) ; }","This function retrieves a list of occurrences of a CandidateAnswerVariant; it throws a missing feature exception if the ""occurrences"" feature does not exist.",getter for occurrences - gets The occurrences of this variant .,Count all occurrences of a CandidateAnswerVariant.
"private void writeJsonInteger ( long num ) throws IOException { context . write ( ) ; String str = Long . toString ( num ) ; boolean escapeNum = context . escapeNum ( ) ; if ( escapeNum ) { transport . write ( QUOTE ) ; } try { byte [ ] buf = str . getBytes ( ""UTF-8"" ) ; transport . write ( buf ) ; } catch ( UnsupportedEncodingException e ) { throw new AssertionError ( e ) ; } if ( escapeNum ) { transport . write ( QUOTE ) ; } }","This function converts a long number to a string and writes it to a transport as a json integer, and adds quotation marks if required due to special characters.",wrapped in quotes to output as a Json string .,Translate a string into json integer.
void freestate ( State s ) { assert s != null ; assert s . nins == 0 ; assert s . nouts == 0 ; if ( s . next != null ) { s . next . prev = s . prev ; } else { assert s == slast ; slast = s . prev ; } if ( s . prev != null ) { s . prev . next = s . next ; } else { assert s == states ; states = s . next ; } },"This function removes a state from a doubly linked list if it is not null and its 'nins' and 'nouts' fields are zero, ensuring that it's the end or start of the list when removing it.",Unwire a state from the NFA .,Removes any element of the list from the start line.
public void calcElementSize ( ) { int total = 0 ; for ( Variable v : members ) { total += v . getElementSize ( ) * v . getSize ( ) ; } elementSize = total ; },This function calculates the total size of all elements in the 'members' array by accumulating the product of each variable's individual element size and its size.,Force recalculation of size of one element of this structure - equals the sum of sizes of its members . This is used only by low level classes like IOSPs .,Calculate the total size of all elements in the member array.
public List < String > groupNames ( ) { if ( groupNames == null ) { groupNames = new ArrayList < String > ( groupInfo . keySet ( ) ) ; } return groupNames ; },"This function returns a list of group names; if the list is null, it initializes it with the keys from the groupInfo map.",Gets the names of all capture groups,Returns a list of group names. If the list is null then it is invoked with the names specified in the groupInfo - encoding!
@ JsonIgnore public List < String > getPolymerAndGroupingIDs ( ) { List < String > listOfIDs = new ArrayList < String > ( ) ; for ( PolymerNotation polymer : listOfPolymers ) { listOfIDs . add ( polymer . getPolymerID ( ) . getId ( ) ) ; } for ( GroupingNotation grouping : listOfGroupings ) { listOfIDs . add ( grouping . getGroupID ( ) . getId ( ) ) ; } return listOfIDs ; },"This function retrieves a list of IDs from ""PolymerNotation"" and ""GroupingNotation"" objects stored in the ""listOfPolymers"" and ""listOfGroupings"" collections respectively, ignoring the JSON annotations during serialization/deserialization.",method to get the ID s from all polymers and groups,Returns the IDs of the specified polymers.
"public static int findNext ( String str , char separator , char escapeChar , int start , StringBuilder split ) { int numPreEscapes = 0 ; for ( int i = start ; i < str . length ( ) ; i ++ ) { char curChar = str . charAt ( i ) ; if ( numPreEscapes == 0 && curChar == separator ) { // separator return i ; } else { split . append ( curChar ) ; numPreEscapes = ( curChar == escapeChar ) ? ( ++ numPreEscapes ) % 2 : 0 ; } } return - 1 ; }","This function searches for the next occurrence of a separator character in a string, while ignoring escaped separators, and extracts the substring up to that point.",Finds the first occurrence of the separator character ignoring the escaped separators starting from the index . Note the substring between the index and the position of the separator is passed .,Finds next occurrence of separator character.
"public static boolean haveVotersReachedPosition ( final ClusterMember [ ] clusterMembers , final long position , final long leadershipTermId ) { for ( final ClusterMember member : clusterMembers ) { if ( member . vote != null && ( member . logPosition < position || member . leadershipTermId != leadershipTermId ) ) { return false ; } } return true ; }","This function checks if all members in the given cluster have reached a specified log position within the current leadership term, returning false if any member has not.",Has the members of the cluster the voted reached the provided position in their log .,Checks if any of the members in the given cluster have reached a status as logged.
"private static String detailErrMsg ( String clientErrMsg , ResponseCommand responseCommand ) { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) { return String . format ( ""%s, ServerErrorMsg:%s"" , clientErrMsg , resp . getErrorMsg ( ) ) ; } else { return String . format ( ""%s, ServerErrorMsg:null"" , clientErrMsg ) ; } }",This function formats and returns a detailed error message string by combining the client error message and the server error message from the response command.,Detail your error msg with the error msg returned from response command,Formats the error message as a String.
"protected String resolveExternalSystem ( String systemId , String resolver ) throws MalformedURLException , IOException { Resolver r = queryResolver ( resolver , ""i2l"" , systemId , null ) ; if ( r != null ) { return r . resolveSystem ( systemId ) ; } else { return null ; } }","This function is used to resolve an external system using the provided systemId and resolver, and it will return a resolved system string or null if the resolver does not exist.",Query an external RFC2483 resolver for a system identifier .,resolve an external system.
"public void forEachBeanType ( final Class type , final Consumer < String > beanNameConsumer ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , type ) ) { beanNameConsumer . accept ( bd . name ) ; } } ) ; }","This function iterates over each bean of a specific type and performs a given action, provided by the Consumer, on the bean's name.",Iterates all beans that are of given type .,This method is used to iterate over each type of bean and perform a given action on the name of the bean.
"public UserCustomCursor query ( BoundingBox boundingBox , Projection projection ) { BoundingBox featureBoundingBox = projectBoundingBox ( boundingBox , projection ) ; return query ( featureBoundingBox ) ; }","This function projects a given bounding box using a specified projection, and then queries the user custom cursor based on the resultant feature bounding box.",Query for rows within the bounding box in the provided projection,This method attempts to locate a custom bounding box.
public JsonArray addAll ( final JsonArray array ) { Objects . requireNonNull ( array ) ; list . addAll ( array . list ) ; return this ; },"This function adds all elements from the specified JsonArray to the end of the list, ensuring that the array is not null, and returns the updated JsonArray.",Appends all of the elements in the specified array to the end of this JSON array .,Adds the elements of the specified JsonArray to the end of this list.
"public FactSheetListResponse getFactSheets ( String type , String relationTypes , Integer pageSize , String cursor , Boolean permissions ) throws ApiException { Object localVarPostBody = null ; // create path and map variables String localVarPath = ""/factSheets"" . replaceAll ( ""\\{format\\}"" , ""json"" ) ; // query params List < Pair > localVarQueryParams = new ArrayList < Pair > ( ) ; Map < String , String > localVarHeaderParams = new HashMap < String , String > ( ) ; Map < String , Object > localVarFormParams = new HashMap < String , Object > ( ) ; localVarQueryParams . addAll ( apiClient . parameterToPairs ( """" , ""type"" , type ) ) ; localVarQueryParams . addAll ( apiClient . parameterToPairs ( """" , ""relationTypes"" , relationTypes ) ) ; localVarQueryParams . addAll ( apiClient . parameterToPairs ( """" , ""pageSize"" , pageSize ) ) ; localVarQueryParams . addAll ( apiClient . parameterToPairs ( """" , ""cursor"" , cursor ) ) ; localVarQueryParams . addAll ( apiClient . parameterToPairs ( """" , ""permissions"" , permissions ) ) ; final String [ ] localVarAccepts = { ""application/json"" } ; final String localVarAccept = apiClient . selectHeaderAccept ( localVarAccepts ) ; final String [ ] localVarContentTypes = { ""application/json"" } ; final String localVarContentType = apiClient . selectHeaderContentType ( localVarContentTypes ) ; String [ ] localVarAuthNames = new String [ ] { ""token"" } ; GenericType < FactSheetListResponse > localVarReturnType = new GenericType < FactSheetListResponse > ( ) { } ; return apiClient . invokeAPI ( localVarPath , ""GET"" , localVarQueryParams , localVarPostBody , localVarHeaderParams , localVarFormParams , localVarAccept , localVarContentType , localVarAuthNames , localVarReturnType ) ; }","This function retrieves a list of fact sheets based on provided type, relation types, page size, cursor, and permissions; it throws an ApiException if the request fails.",getFactSheets Retrieves all Fact Sheets,Returns fact sheets.
public Object lookupName ( String name ) { final Node childNode = getNode ( ) . getChild ( name ) ; if ( childNode == null ) { return null ; } else { return childNode . get ( CACHE_NODE_MAP_KEY ) ; } },"This function returns the CACHE_NODE_MAP_KEY value for a given child node matching the specified name, or null if no such node exists.",Lookup of the activity context id bound to the specified aci name,Returns the value for the child node with the given name.
"@ Generated ( value = ""com.sun.tools.xjc.Driver"" , date = ""2018-10-12T02:52:47+02:00"" , comments = ""JAXB RI v2.2.11"" ) public void setErdwaerme ( JAXBElement < Object > value ) { this . erdwaerme = value ; }","This function sets the value of 'erdwaerme' to the given value, and it is auto-generated by the JAXB RI v2.2.11 tool.",Sets the value of the erdwaerme property .,Set the value for this type using the default mode default setting.
"public String getVocab ( MixinSource mixinSource , Object bean , Class < ? > mixInClass ) { if ( proxyUnwrapper != null ) { bean = proxyUnwrapper . unwrapProxy ( bean ) ; } // determine vocab in context String classVocab = bean == null ? null : vocabFromClassOrPackage ( bean . getClass ( ) ) ; final Vocab mixinVocab = findAnnotation ( mixInClass , Vocab . class ) ; Object nestedContextProviderFromMixin = getNestedContextProviderFromMixin ( mixinSource , bean , mixInClass ) ; String contextProviderVocab = null ; if ( nestedContextProviderFromMixin != null ) { contextProviderVocab = getVocab ( mixinSource , nestedContextProviderFromMixin , null ) ; } String vocab ; if ( mixinVocab != null ) { vocab = mixinVocab . value ( ) ; // wins over class } else if ( classVocab != null ) { vocab = classVocab ; // wins over context provider } else if ( contextProviderVocab != null ) { vocab = contextProviderVocab ; // wins over last resort } else { vocab = HTTP_SCHEMA_ORG ; } return vocab ; }","This function retrieves the vocab value from the given MixinSource and bean object, prioritizing vocab from Mixin annotation over class vocab and context provider vocab, and falling back on a default vocab if none is provided.",Gets vocab for given bean .,Returns default vocab value if supplied.
"private String getDefaultIconRef ( ) { ProjectClassLoaders cls = getContext ( ) . getProjectClassLoaders ( ) ; if ( cls . isClassInCompileClasspath ( false , ""io.fabric8.funktion.runtime.Main"" ) || getContext ( ) . hasDependency ( ""io.fabric8.funktion"" , null ) ) { return ""funktion"" ; } if ( cls . isClassInCompileClasspath ( false , ""org.apache.camel.CamelContext"" ) ) { return ""camel"" ; } if ( getContext ( ) . hasPlugin ( null , SpringBootConfigurationHelper . SPRING_BOOT_MAVEN_PLUGIN_ARTIFACT_ID ) || cls . isClassInCompileClasspath ( false , ""org.springframework.boot.SpringApplication"" ) ) { return ""spring-boot"" ; } if ( cls . isClassInCompileClasspath ( false , ""org.springframework.core.Constants"" ) ) { return ""spring"" ; } if ( cls . isClassInCompileClasspath ( false , ""org.vertx.java.core.Handler"" , ""io.vertx.core.Handler"" ) ) { return ""vertx"" ; } if ( getContext ( ) . hasPlugin ( ""org.wildfly.swarm"" , ""wildfly-swarm-plugin"" ) || getContext ( ) . hasDependency ( ""org.wildfly.swarm"" , null ) ) { return ""wildfly-swarm"" ; } if ( getContext ( ) . hasPlugin ( ""io.thorntail"" , ""thorntail-maven-plugin"" ) || getContext ( ) . hasDependency ( ""io.thorntail"" , null ) ) { // use the WildFly Swarm icon until there's a dedicated Thorntail icon // Thorntail is a new name of WildFly Swarm return ""wildfly-swarm"" ; } return null ; }",This function returns the default icon reference based on the presence of certain classes or dependencies in the project's classpath.,Lets use the project and its classpath to try figure out what default icon to use,Returns the default icon reference based on the presence of the specified classes or dependencies in the classpath of a project.
"public void addConditionFactor ( ConditionFactor factor ) throws WebDAVException { if ( conditionFactors . contains ( factor ) ) throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( ""error.parseDuplicateEntry"" ) ) ; //$NON-NLS-1$ conditionFactors . addElement ( factor ) ; }","This function is used to add a ConditionFactor to the conditionFactors vector; if the factor already exists in the vector, it throws a WebDAVException indicating a duplicate entry error.",Add a ConditionFactor to a ConditionTerm .,"Add a ConditionFactor to the specified conditionFares. If the given condition is already present in the vector it will throw symlinks out of the field if there is, then the SPI will be replaced with the new SCIFE!"
"public long getSize ( final String fileName ) { final Long result = this . sizes . get ( fileName ) ; if ( result == null ) { throw new IllegalStateException ( String . format ( ""Stream '%s' not closed or was not added"" , fileName ) ) ; } return result ; }","This function retrieves the size of a specified file, and throws an exception if the file stream is not closed or if the file was not added.",Get the size of a closed file,Return the size of the file.
"public List < Transaction > getAddressTransactions ( String address , int limit ) throws IOException { return getAddressTransactions ( address , limit , null ) ; }",This function retrieves a limited list of transaction details linked to a specific address.,Returns transactions by address with limit .,Returns transaction details with an address
"public static Class checkInterfaces ( Class classOrInterfaceWithInterfaces , String interfaceSearched ) { Class returnValue = null ; if ( classOrInterfaceWithInterfaces . getName ( ) . compareTo ( interfaceSearched ) == 0 ) { return classOrInterfaceWithInterfaces ; } // we do check only on get interfaces for ( Class iface : classOrInterfaceWithInterfaces . getInterfaces ( ) ) { if ( iface . getName ( ) . compareTo ( interfaceSearched ) == 0 ) { returnValue = iface ; } else { returnValue = checkInterfaces ( iface , interfaceSearched ) ; } if ( returnValue != null ) break ; } if ( ! classOrInterfaceWithInterfaces . isInterface ( ) && returnValue == null ) { Class superClass = classOrInterfaceWithInterfaces . getSuperclass ( ) ; if ( superClass != null ) { returnValue = checkInterfaces ( superClass , interfaceSearched ) ; } } return returnValue ; }","This function checks if a given Class or Interface implements a specific interface, returning the Class of the interface if found.",Searches for provided interface in passed Class object - it can be class or interface . If it finds it return instance of it .,Returns the value of the interface given.
"private void postParseSteps ( final VirtualFile persistence_xml , final PersistenceUnitMetadataHolder puHolder , final DeploymentUnit deploymentUnit ) { for ( PersistenceUnitMetadata pu : puHolder . getPersistenceUnits ( ) ) { // set URLs List < URL > jarfilesUrls = new ArrayList < URL > ( ) ; if ( pu . getJarFiles ( ) != null ) { for ( String jar : pu . getJarFiles ( ) ) { jarfilesUrls . add ( getRelativeURL ( persistence_xml , jar ) ) ; } } pu . setJarFileUrls ( jarfilesUrls ) ; URL url = getPersistenceUnitURL ( persistence_xml ) ; pu . setPersistenceUnitRootUrl ( url ) ; String scopedPersistenceUnitName ; /**
             * WFLY-5478 allow custom scoped persistence unit name hint in persistence unit definition.
             * Specified scoped persistence unit name needs to be unique across application server deployments.
             * Application is responsible for picking a unique name.
             * Currently, a non-unique name will result in a DuplicateServiceException deployment failure:
             *   org.jboss.msc.service.DuplicateServiceException: Service jboss.persistenceunit.my2lccustom#test_pu.__FIRST_PHASE__ is already registered
             */ scopedPersistenceUnitName = Configuration . getScopedPersistenceUnitName ( pu ) ; if ( scopedPersistenceUnitName == null ) { scopedPersistenceUnitName = createBeanName ( deploymentUnit , pu . getPersistenceUnitName ( ) ) ; } else { ROOT_LOGGER . tracef ( ""persistence unit '%s' specified a custom scoped persistence unit name hint "" + ""(jboss.as.jpa.scopedname=%s).  The specified name *must* be unique across all application server deployments."" , pu . getPersistenceUnitName ( ) , scopedPersistenceUnitName ) ; if ( scopedPersistenceUnitName . indexOf ( ' ' ) != - 1 ) { throw JpaLogger . ROOT_LOGGER . invalidScopedName ( scopedPersistenceUnitName , ' ' ) ; } } pu . setScopedPersistenceUnitName ( scopedPersistenceUnitName ) ; } }","This function post-processes parsed persistence units by setting URLs and scoped persistence unit names extracted from the persistence unit metadata holder, and handles exceptional cases like a non-unique name which would result in a deployment failure.",Some of this might need to move to the install phase,This method post - processed parsed persistence units.
"public PipelineConfiguration upgradeIfNecessary ( StageLibraryTask library , PipelineConfiguration pipelineConf , List < Issue > issues ) { Preconditions . checkArgument ( issues . isEmpty ( ) , ""Given list of issues must be empty."" ) ; boolean upgrade ; // Firstly upgrading schema if needed, then data upgrade = needsSchemaUpgrade ( pipelineConf , issues ) ; if ( upgrade && issues . isEmpty ( ) ) { pipelineConf = upgradeSchema ( library , pipelineConf , issues ) ; } // Something went wrong with the schema upgrade if ( ! issues . isEmpty ( ) ) { return null ; } // Upgrading data if needed upgrade = needsUpgrade ( library , pipelineConf , issues ) ; if ( upgrade && issues . isEmpty ( ) ) { //we try to upgrade only if we have all defs for the pipelineConf pipelineConf = upgrade ( library , pipelineConf , issues ) ; } return ( issues . isEmpty ( ) ) ? pipelineConf : null ; }","This function checks if a pipeline configuration requires an upgrade, and if necessary, performs a schema upgrade followed by data upgrade, returning the upgraded configuration or null if there are any issues.",Upgrade whole pipeline at once and return updated variant .,Performs a schema upgrade if necessary.
"protected void sweepTail ( ) { Integer deviceId = allocator . getDeviceId ( ) ; int cnt = 0 ; // we get number of issued commands for specific device long lastCommandId = deviceClocks . get ( deviceId ) . get ( ) ; for ( int l = 0 ; l < configuration . getCommandLanesNumber ( ) ; l ++ ) { Queue < cudaEvent_t > queue = eventsBarrier . get ( deviceId ) . get ( l ) ; if ( queue . size ( ) >= MAX_EXECUTION_QUEUE || laneClocks . get ( deviceId ) . get ( l ) . get ( ) < lastCommandId - MAX_EXECUTION_QUEUE ) { cudaEvent_t event = queue . poll ( ) ; if ( event != null && ! event . isDestroyed ( ) ) { event . synchronize ( ) ; event . destroy ( ) ; cnt ++ ; } } } deviceClocks . get ( deviceId ) . incrementAndGet ( ) ; //  log.info(""Events sweeped: [{}]"", cnt); }","This function `sweepTail` handles the queue of commands for a specific device, synchronizing and destroying any events that meet certain conditions, then updates the device's command clock.",This method ensures the events in the beginning of FIFO queues are finished,Handle the queue of commands on the specified device.
"public void attach ( HttpServletRequest httpRequest , HttpServletResponse httpResponse ) { // takes care to not override request URL, locale and request path values if set by request pre-processor if ( requestURL == null ) { requestURL = httpRequest . getRequestURI ( ) ; } if ( locale == null ) { locale = httpRequest . getLocale ( ) ; } if ( requestPath == null ) { // request URI and context path cannot ever be null requestPath = httpRequest . getRequestURI ( ) . substring ( httpRequest . getContextPath ( ) . length ( ) ) ; } this . httpRequest = httpRequest ; this . httpResponse = httpResponse ; this . attached = true ; }","This function attaches an HTTP request and response, ensuring that the request URL, locale, and request path values are not overridden if they have been set by a request pre-processor.",Attach this instance to HTTP servlet request . Load this instance state from HTTP servlet request and mark it as attached .,Attach an HTTP request to an API request and response.
"public RecordPrimaryKey extractPrimaryKey ( Object o ) { HollowObjectTypeMapper typeMapper = ( HollowObjectTypeMapper ) getTypeMapper ( o . getClass ( ) , null , null ) ; return new RecordPrimaryKey ( typeMapper . getTypeName ( ) , typeMapper . extractPrimaryKey ( o ) ) ; }",This function extracts the primary key from a given object using a HollowObjectTypeMapper and returns it as a RecordPrimaryKey.,Extracts the primary key from the specified POJO .,Returns the primary key from the given object.
"public void removePropertyChangeListener ( String p , PropertyChangeListener l ) { if ( listeners == null ) { return ; } synchronized ( listeners ) { listeners . remove ( l ) ; } }",This function removes a specified PropertyChangeListener from the listeners list based on the provided string parameter.,Removes the specified property change listener from the list of active listeners .,Removes a PropertyChangeListener from the Listeners List if the list value is not matching the specified string.
"@ Override public long skip ( final long n ) throws IOException { if ( n <= avail ) { final int m = ( int ) n ; pos += m ; avail -= m ; readBytes += n ; return n ; } long toSkip = n - avail , result = 0 ; avail = 0 ; while ( toSkip != 0 && ( result = is == System . in ? skipByReading ( toSkip ) : is . skip ( toSkip ) ) < toSkip ) { if ( result == 0 ) { if ( is . read ( ) == - 1 ) break ; toSkip -- ; } else toSkip -= result ; } final long t = n - ( toSkip - result ) ; readBytes += t ; return t ; }","This function overrides the skip method by advancing the input stream with the specified number of bytes, returning the actual number of bytes skipped; it also keeps track of the total number of bytes read from the stream.",Skips over and discards the given number of bytes of data from this fast buffered input stream .,skip method. Returns number of bytes read from stream despite notifying skippers if needed!
"public static void convertCell ( final SheetConfiguration sheetConfig , final FacesCell fcell , final Cell poiCell , final Map < String , CellRangeAddress > cellRangeMap , final int originRowIndex , final CellAttributesMap cellAttributesMap , final String saveAttrs ) { CellRangeAddress caddress ; String key = getCellIndexNumberKey ( poiCell ) ; caddress = cellRangeMap . get ( key ) ; if ( caddress != null ) { // has col or row span fcell . setColspan ( caddress . getLastColumn ( ) - caddress . getFirstColumn ( ) + 1 ) ; fcell . setRowspan ( caddress . getLastRow ( ) - caddress . getFirstRow ( ) + 1 ) ; } CellControlsUtility . setupControlAttributes ( originRowIndex , fcell , poiCell , sheetConfig , cellAttributesMap ) ; fcell . setHasSaveAttr ( SaveAttrsUtility . isHasSaveAttr ( poiCell , saveAttrs ) ) ; }","This function converts a POI cell into a FacesCell, setting its attributes including row span, column span, and control attributes, and determines if it has saved attributes.",set up facesCell s attribute from poiCell and others .,Returns a POI to sa cell.
public static int roundUpToPowerOf2 ( int number ) { int rounded = number >= 1_000 ? 1_000 : ( rounded = Integer . highestOneBit ( number ) ) != 0 ? ( Integer . bitCount ( number ) > 1 ) ? rounded << 1 : rounded : 1 ; return rounded ; },"This function rounds up the input number to the nearest power of 2, if the number is under 1000, otherwise it returns 1000.",Round up to the nearest power of 2,Returns the nearest power of 2 if the number is below 1000.
"public void registerResourceAdapterDeployment ( ResourceAdapterDeployment deployment ) { if ( deployment == null ) throw new IllegalArgumentException ( ConnectorLogger . ROOT_LOGGER . nullVar ( ""Deployment"" ) ) ; DEPLOYMENT_CONNECTOR_REGISTRY_LOGGER . tracef ( ""Adding deployment: %s"" , deployment ) ; deployments . add ( deployment ) ; }","This function registers a ResourceAdapterDeployment object to the deployments list, logging the operation and throwing an exception if the provided deployment is null.",Register a resource adapter deployment,AdapterDeployment will be used to pass the current deployment information to the local resource.
protected boolean noMoreCharacters ( ) throws IOException { if ( avail == 0 ) { avail = is . read ( buffer ) ; if ( avail <= 0 ) { avail = 0 ; return true ; } pos = 0 ; } return false ; },"This function reads into the buffer and returns true if there are no more characters available, otherwise it resets the reading position and returns false.",Checks whether no more bytes will be returned .,Reads the contents of this buffer.
"static public Variable findVariableWithAttributeValue ( Structure struct , String attName , String attValue ) { for ( Variable v : struct . getVariables ( ) ) { Attribute att = v . findAttributeIgnoreCase ( attName ) ; if ( ( att != null ) && att . getStringValue ( ) . equals ( attValue ) ) return v ; } return null ; }","This function searches for and returns a variable in a given structure that has a specified attribute name and value, returning null if no such variable is found.",Find first member variable in this struct with given attribute name and value,Find variable in structure with given attribute name and value. If no such variable is found it will be null if there is none - nul!
"private TreeItem doTree ( FQDNNode localRoot ) { TreeItem localLeaf = new TreeItem ( ) ; LogTreeNode logTreeNode = new LogTreeNode ( browseContainer , localRoot . getShortName ( ) , localRoot . getFqdName ( ) , localRoot . isWasLeaf ( ) , this ) ; localLeaf . setWidget ( logTreeNode ) ; if ( localRoot . getChildren ( ) . size ( ) > 0 ) { Tree t = new Tree ( ) ; ArrayList names = new ArrayList ( localRoot . getChildrenNames ( ) ) ; Collections . sort ( names ) ; Iterator it = names . iterator ( ) ; while ( it . hasNext ( ) ) { t . addItem ( doTree ( localRoot . getChild ( ( String ) it . next ( ) ) ) ) ; } localLeaf . addItem ( t ) ; } return localLeaf ; }","This function constructs a tree structure from a root node, sorting children nodes alphabetically, and encapsulates the node details in a widget.",TMP DEV METHODS,Construct a tree from symorgan.
"public static Object convertValue ( String text , String typeName ) throws ClassNotFoundException , IntrospectionException { // see if it is a primitive type first Class < ? > typeClass = Classes . getPrimitiveTypeForName ( typeName ) ; if ( typeClass == null ) { ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; typeClass = loader . loadClass ( typeName ) ; } PropertyEditor editor = PropertyEditorManager . findEditor ( typeClass ) ; if ( editor == null ) { throw new IntrospectionException ( ""No property editor for type="" + typeClass ) ; } editor . setAsText ( text ) ; return editor . getValue ( ) ; }","This function converts a string value to a specified object type, supporting both primitive and class types, and throws an exception if no suitable property editor is found for the type.",Convert a string value into the true value for typeName using the PropertyEditor associated with typeName .,Returns the value for the specified object type to the editor.
"public void init ( ) { /* If the parent and name are equal to null,
         * use the classname to load listFromClassLoader.
    	 * */ if ( name == null && parent == null ) { this . setDetailMessage ( ""{"" + this . getClass ( ) . getName ( ) + DETAIL_KEY + ""}"" ) ; this . setSummaryMessage ( ""{"" + this . getClass ( ) . getName ( ) + SUMMARY_KEY + ""}"" ) ; /* If the parent is null and the name is not,
         * use the name to load listFromClassLoader.
         */ } else if ( name != null && parent == null ) { this . setDetailMessage ( ""{"" + ""message."" + getName ( ) + DETAIL_KEY + ""}"" ) ; this . setSummaryMessage ( ""{"" + ""message."" + getName ( ) + SUMMARY_KEY + ""}"" ) ; /* If the parent is present, initialize the message keys
         * with the parent name.
         */ } else if ( parent != null ) { this . setDetailMessage ( ""{"" + ""message."" + parent + DETAIL_KEY + ""}"" ) ; this . setSummaryMessage ( ""{"" + ""message."" + parent + SUMMARY_KEY + ""}"" ) ; } }","This function initializes the detail and summary messages using either the classname, provided name, or parent name as keys if they are not null.",The init method tries to generate the message keys . You should only call the init method if you don t inject values into the detailMessage and summaryMessage .,Initializes the messages with the specified name.
"@ Override public IComplexNDArray putColumn ( int column , INDArray toPut ) { assert toPut . isVector ( ) && toPut . length ( ) == rows ( ) : ""Illegal length for row "" + toPut . length ( ) + "" should have been "" + columns ( ) ; IComplexNDArray r = getColumn ( column ) ; if ( toPut instanceof IComplexNDArray ) { IComplexNDArray putComplex = ( IComplexNDArray ) toPut ; for ( int i = 0 ; i < r . length ( ) ; i ++ ) { IComplexNumber n = putComplex . getComplex ( i ) ; r . putScalar ( i , n ) ; } } else { for ( int i = 0 ; i < r . length ( ) ; i ++ ) r . putScalar ( i , Nd4j . createDouble ( toPut . getDouble ( i ) , 0 ) ) ; } return this ; }","This function replaces a specified column in a complex NDArray with a provided INDArray, enforces integrity of dimensions and handles both complex and non-complex inputs.",Insert a column in to this array Will throw an exception if this ndarray is not a matrix,Replaces a column containing NDArray with IND array.
"public static void add ( int type , Throwable t ) { // don't add null throwables if ( t == null ) return ; try { fireOnThrowable ( type , t ) ; } catch ( Throwable bad ) { // don't let these propagate, that could introduce unwanted side-effects System . err . println ( ""Unable to handle throwable: "" + t + "" because of:"" ) ; bad . printStackTrace ( ) ; } }","This function adds a throwable of a specified type to a list unless it is null, and logs an error if the throwable cannot be handled, to avoid propagating any further issues.",Add a throwable that is to be handled .,Add a throwable to the specified type in the list.
"@ Generated ( value = ""com.sun.tools.xjc.Driver"" , date = ""2018-10-12T02:54:50+02:00"" , comments = ""JAXB RI v2.2.11"" ) public List < String > getVermarktungsart ( ) { if ( vermarktungsart == null ) { vermarktungsart = new ArrayList < String > ( ) ; } return this . vermarktungsart ; }","This function retrieves the marketing method and initializes it as an ArrayList if it's null, generated via the JAXB RI v2.2.11 tool.",Gets the value of the vermarktungsart property .,Returns the marketing model for the JAXB RI v2.2.11 product.
"public static ResourceChangeHandler create ( final WroManagerFactory managerFactory , final Log log ) { notNull ( managerFactory , ""WroManagerFactory was not set"" ) ; notNull ( log , ""Log was not set"" ) ; return new ResourceChangeHandler ( ) . setManagerFactory ( managerFactory ) . setLog ( log ) ; }",This function creates a new instance of ResourceChangeHandler by setting its WroManagerFactory and Log if they're not null.,Factory method which requires all mandatory fields .,Create a ResourceChangeHandler for this Manager.
"public static RegExpAndDurationTimeCoverageEnhancer getInstanceToMatchOnDatasetPath ( String matchPattern , String substitutionPattern , String duration ) { return new RegExpAndDurationTimeCoverageEnhancer ( matchPattern , substitutionPattern , duration , MatchTarget . DATASET_PATH ) ; }","This function returns an instance of RegExpAndDurationTimeCoverageEnhancer with the given match pattern, substitution pattern, and duration that targets the dataset's path.",Factory method that returns a RegExpAndDurationTimeCoverageEnhancer instance that will apply the match pattern to the dataset path .,Returns a ghost instance for regExpAndDurationTimeCoverageEnhancer with the given match pattern and substitution pattern. This method may use the timeCOVERAGE method to fetch regexexAnddurationtimeCrowage in conjunction with this instance if it matches the pattern specified in the dataset ; however it does not necessarily mean that the regExexExExchangeTimeEnchancer match the specified length of time and that it will be in accordance with that reference - the matching pattern used in this case
"public DataIterator getDataIterator ( ucar . unidata . geoloc . Station s , Date start , Date end ) throws IOException { return new StationDateDataIterator ( s , start , end ) ; }",This function fetches a data iterator for a specific geolocation station between the specified start and end dates.,Get data for this Station within the specified date range .,Returns a iterator for s geolocation between the specified start and end dates.
public List < File > findAll ( ) { List < File > allFiles = new ArrayList <> ( ) ; File file ; while ( ( file = nextFile ( ) ) != null ) { allFiles . add ( file ) ; } return allFiles ; },This function retrieves and returns a list of all available files using the nextFile() method.,Finds all files and returns list of founded files .,Returns the list of available files.
"private static boolean checkChangesFilledUpTo ( final FileChanges changesContainer , final long pageIndex ) { if ( changesContainer == null ) { return true ; } else if ( changesContainer . isNew || changesContainer . maxNewPageIndex > - 2 ) { return pageIndex < changesContainer . maxNewPageIndex + 1 ; } else return ! changesContainer . truncate ; }","This function checks whether changes, up to a given page index, have been filled in the provided FileChanges container.",This check if a file was trimmed or trunked in the current atomic operation .,Check if changes have been filled in the supplied FileChanges container.
"@ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > concatMapIterable ( Function < ? super T , ? extends Iterable < ? extends U > > mapper ) { return concatMapIterable ( mapper , 2 ) ; }","This function transforms the items emitted by the Flowable sequence into Iterables and then flattens these into a new Flowable sequence, handling backpressure and scheduling support.",Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .,Flowables are replaced by i - filtered streams that are converted to a new Streamable sequence.
"private void sendHandshake ( ) throws InvalidHandshakeException { String path ; String part1 = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( part1 == null || part1 . length ( ) == 0 ) path = ""/"" ; else path = part1 ; if ( part2 != null ) path += ' ' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? "":"" + port : """" ) ; HandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; handshake . setResourceDescriptor ( path ) ; handshake . put ( ""Host"" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { handshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( handshake ) ; }","This function initiates a handshake process by constructing the resource descriptor and host, setting them within a new handshake instance, and starts the handshake via the engine.",Create and send the handshake to the other endpoint,This method initiates the handshake process.
public OQueryAbstract setFetchPlan ( final String fetchPlan ) { OFetchHelper . checkFetchPlanValid ( fetchPlan ) ; if ( fetchPlan != null && fetchPlan . length ( ) == 0 ) this . fetchPlan = null ; else this . fetchPlan = fetchPlan ; return this ; },This function sets the fetch plan to the specified string value after validating it and removes it if the string is empty.,Sets the fetch plan to use .,Sets the fetch plan for the specified string value.
"@ Generated ( value = ""com.sun.tools.xjc.Driver"" , date = ""2018-10-12T02:48:12+02:00"" , comments = ""JAXB RI v2.2.11"" ) public void setCity ( LocationStructure . City value ) { this . city = value ; }",This function sets the value of the city in the LocationStructure using the JAXB RI v2.2.11 software tool.,Sets the value of the city property .,Sets the location for this city.
@ Override public void addAll ( Iterable < Attribute > atts ) { for ( Attribute att : atts ) addAttribute ( att ) ; },This function overrides the existing 'addAll' method to add all attributes from the given iterable into the current attribute set.,Add all ; replace old if has same name,Add All attributes from the given iterable to the current attribute set.
"private InputStream getResourceAsStream ( String uri ) throws JasperException { try { // see if file exists on the filesystem first String real = ctxt . getRealPath ( uri ) ; if ( real == null ) { return ctxt . getResourceAsStream ( uri ) ; } else { return new FileInputStream ( real ) ; } } catch ( FileNotFoundException ex ) { // if file not found on filesystem, get the resource through // the context return ctxt . getResourceAsStream ( uri ) ; } }","This function attempts to retrieve a resource as an input stream based on the provided URI, initially from the file system and if not found, it falls back to the context resources.",the following is a workaround until these problems are resolved .,Returns the resource in the context.
"static public String replace ( String s , char out , String in ) { if ( s . indexOf ( out ) < 0 ) { return s ; } // gotta do it StringBuilder sb = new StringBuilder ( s ) ; replace ( sb , out , in ) ; return sb . toString ( ) ; }","This function replaces all occurrences of a specific character in a string with a provided string, returning the modified string.",Replace any char out in s with in .,Replaces all characters with the given string.
"public String getDepLabel ( ) { if ( Token_Type . featOkTst && ( ( Token_Type ) jcasType ) . casFeat_depLabel == null ) jcasType . jcas . throwFeatMissing ( ""depLabel"" , ""edu.cmu.lti.oaqa.type.nlp.Token"" ) ; return jcasType . ll_cas . ll_getStringValue ( addr , ( ( Token_Type ) jcasType ) . casFeatCode_depLabel ) ; }","This function returns the dependency label associated with a given token; if the dependency label is not found, it throws a feature missing exception.",getter for depLabel - gets The dependency label of the token with respect to its head .,Returns the dependency label for the given token.
"public void registerEventID ( String description , String key , String value ) { BufferedWriter bufferedWriter ; FileOutputStream out = null ; try { out = new FileOutputStream ( eventPropertiesPath , true ) ; bufferedWriter = new BufferedWriter ( new OutputStreamWriter ( out ) ) ; doWithLock ( out . getChannel ( ) , lock -> { unlockedReloadFile ( ) ; if ( getEventID ( key ) != null ) { return ; } try { bufferedWriter . write ( ""\n\n"" + key + ""_DESCRIPTION = "" + description + ""\n"" + key + "" = "" + value ) ; bufferedWriter . flush ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } ) ; } catch ( FileNotFoundException e ) { error ( ""Unable find file"" , e ) ; } finally { try { if ( out != null ) { out . close ( ) ; } } catch ( IOException e ) { error ( ""Unable to close lock"" , e ) ; } } }","This function registers an event ID by writing a given key, description and value to a file, and handles any potential IOExceptions that might occur during this process.",Registers or adds an event to the local_events . properties file,Registrate an event ID for the event.
"private void addConstantLongOrDouble ( final int index , final int tag , final long value ) { add ( new Entry ( index , tag , value , hash ( tag , value ) ) ) ; }","This function adds a new entry with a given index, tag, and long/double value to a private collection.",Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table .,Adds a new entry with the specified value to the list.
public void initializeLookups ( DecisionTree thisNode ) { // Scan over all the decision trees children at this point inserting them into the lookup table depending // on the ordinal of the attribute value that matches them. for ( Iterator < Tree < DecisionTreeElement > > i = thisNode . getChildIterator ( ) ; i . hasNext ( ) ; ) { DecisionTree nextChildTree = ( DecisionTree ) i . next ( ) ; // Get the matching attribute value from the childs decision tree element. OrdinalAttribute matchingValue = nextChildTree . getElement ( ) . getAttributeValue ( ) ; // Insert the matching sub-tree into the lookup table. decisions [ matchingValue . ordinal ( ) ] = nextChildTree ; } },"This function initializes lookups by iterating over all children of a given node in a decision tree, matching the attribute value of each child and inserting them into a lookup table based on the ordinal value of the matching attribute.",Initializes the lookup table for this decision node . The specified decision tree that corresponds to this node is used to extract all the possible outcomes for this decision and these are stored in a lookup table so that future decisions made with this tree will run faster .,Lookups are initialized after the matching attribute value matching the given attribute. Each lookup table should be divided according to the order and the structure of the table based on the condition that the attribute values are the equivalent to each child s child
"public Object evaluate ( final Reader reader , final String sourceName ) throws IOException { notNull ( reader ) ; try { return evaluate ( IOUtils . toString ( reader ) , sourceName ) ; } finally { reader . close ( ) ; } }","This function reads data from the given reader, evaluates it with a specified source name and closes the reader, while throwing an exception if an I/O error occurs.",Evaluates a script from a reader .,Reads the contents of the reader.
"protected static void write ( final StringWriter writer , final String fieldName , final String value ) { writer . write ( fieldName + "": "" + value + ""\n"" ) ; }","This function writes a given field name and its corresponding value to a specific StringWriter object, separating them with a colon and a new line.",Write a field,Writes a field name and sa value to ltd string writer.
"public static boolean contained ( Box3D_I32 boxA , Box3D_I32 boxB ) { return ( boxA . p0 . x <= boxB . p0 . x && boxA . p1 . x >= boxB . p1 . x && boxA . p0 . y <= boxB . p0 . y && boxA . p1 . y >= boxB . p1 . y && boxA . p0 . z <= boxB . p0 . z && boxA . p1 . z >= boxB . p1 . z ) ; }",This function checks if BoxA is entirely contained within BoxB in a 3D space.,Returns true if boxB is contained inside of or is identical to boxA .,Checks if BoxA is entirely contained within BoxB.
private void migrateGenericTransport ( ModelNode addOperation ) { String factoryClass = addOperation . get ( FACTORY_CLASS . getName ( ) ) . asString ( ) ; final String newFactoryClass ; switch ( factoryClass ) { case HORNETQ_NETTY_ACCEPTOR_FACTORY : newFactoryClass = ARTEMIS_NETTY_ACCEPTOR_FACTORY ; break ; case HORNETQ_NETTY_CONNECTOR_FACTORY : newFactoryClass = ARTEMIS_NETTY_CONNECTOR_FACTORY ; break ; default : newFactoryClass = factoryClass ; } addOperation . get ( FACTORY_CLASS . getName ( ) ) . set ( newFactoryClass ) ; },This function is migrating a generic transport based on the factoryClass instance specified in the provided ModelNode add operation.,For generic acceptor and connectors migrate their factory - class attribute if they are using the default Netty ones .,Migrate generic transport based on the specified ModelNode instance in the supplied ModulatedTransport operation
"private void analyze ( FeatureType wantFeatureType ) throws IOException { // for netcdf-3 files, convert record dimension to structure // LOOK may be problems when served via opendap boolean structAdded = ( Boolean ) ds . sendIospMessage ( NetcdfFile . IOSP_MESSAGE_ADD_RECORD_STRUCTURE ) ; if ( tc == null ) { makeTablesDefault ( structAdded ) ; makeNestedTables ( ) ; } else { configResult = tc . getConfig ( wantFeatureType , ds , errlog ) ; if ( configResult != null ) addTableRecurse ( configResult ) ; // kinda stupid else { // use default makeTablesDefault ( structAdded ) ; makeNestedTables ( ) ; } } // find the leaves for ( TableConfig config : tableSet ) { if ( config . children == null ) { // its a leaf NestedTable flatTable = new NestedTable ( ds , config , errlog ) ; leaves . add ( flatTable ) ; } } if ( PointDatasetStandardFactory . showTables ) getDetailInfo ( new Formatter ( System . out ) ) ; }","This function analyzes a specific feature type within a netcdf-3 file, handles exceptions, configures the results, generates tables and finds the leaves of these tables.",Make a NestedTable object for the dataset .,Generate tables for a specific feature type.
"private ResponseHandler < String > getJsonResponseHandler ( final String urlCalledParam ) { // Create a custom response handler ResponseHandler < String > responseHandler = new ResponseHandler < String > ( ) { /**
			 * Process the {@code responseParam} and return text if valid.
			 *
			 * @param responseParam The HTTP response from the server.
			 * @return Text response.
			 * @throws IOException If there are any communication or I/O problems.
			 */ public String handleResponse ( final HttpResponse responseParam ) throws IOException { int status = responseParam . getStatusLine ( ) . getStatusCode ( ) ; if ( status == 404 ) { throw new FluidClientException ( ""Endpoint for Service not found. URL ["" + urlCalledParam + ""]."" , FluidClientException . ErrorCode . CONNECT_ERROR ) ; } else if ( status >= 200 && status < 300 ) { HttpEntity entity = responseParam . getEntity ( ) ; String responseJsonString = ( entity == null ) ? null : EntityUtils . toString ( entity ) ; return responseJsonString ; } else if ( status == 400 ) { //Bad Request... Server Side Error meant for client... HttpEntity entity = responseParam . getEntity ( ) ; String responseJsonString = ( entity == null ) ? null : EntityUtils . toString ( entity ) ; return responseJsonString ; } else { HttpEntity entity = responseParam . getEntity ( ) ; String responseString = ( entity != null ) ? EntityUtils . toString ( entity ) : null ; throw new FluidClientException ( ""Unexpected response status: "" + status + "". "" + responseParam . getStatusLine ( ) . getReasonPhrase ( ) + "". \nResponse Text ["" + responseString + ""]"" , FluidClientException . ErrorCode . IO_ERROR ) ; } } } ; return responseHandler ; }","This function establishes a custom response handler that processes the HTTP response from a server and returns the corresponding text if valid, handling common status code scenarios and throwing exceptions for error conditions.",Get a text based response handler used mainly for JSON .,Handle common status code scenarios and throwing exceptions for error conditions.
"@ Generated ( value = ""com.sun.tools.xjc.Driver"" , date = ""2018-10-12T02:52:47+02:00"" , comments = ""JAXB RI v2.2.11"" ) public GaragenKategorieTyp getObjektKategorie2 ( ) { if ( objektKategorie2 == null ) { return GaragenKategorieTyp . KEINE_ANGABE ; } else { return objektKategorie2 ; } }","This function retrieves the object category 'objektKategorie2', returning a predefined value ('KEINE_ANGABE') if the category is null, otherwise it returns the actual value.",Gets the value of the objektKategorie2 property .,This method returns the object category as a whole. It returns if the parameter - category is null ; otherwise it returns actual value
"public boolean checkGroupId ( String d ) { Pattern p = Pattern . compile ( ""G[1-9][0-9]*"" , Pattern . CASE_INSENSITIVE ) ; Matcher m = p . matcher ( d ) ; LOG . debug ( ""Validation of groupID:"" ) ; if ( m . matches ( ) ) { LOG . debug ( ""GroupID is valid:"" ) ; return true ; } LOG . debug ( ""GroupID is not valid:"" ) ; return false ; }","This function validates if a given string matches the specific Pattern ""G[1-9][0-9]*"", returning true if it does, and false otherwise.",method to validate the group id,Validates if the given string matches the specified pattern.
"@ SuppressWarnings ( ""unchecked"" ) public static < T , R > boolean tryScalarXMapSubscribe ( ObservableSource < T > source , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return true ; } if ( t == null ) { EmptyDisposable . complete ( observer ) ; return true ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , ""The mapper returned a null ObservableSource"" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return true ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return true ; } if ( u == null ) { EmptyDisposable . complete ( observer ) ; return true ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return true ; } return false ; }","This function subscribes an observer to an ObservableSource, mapping the source's emitted values to new ObservableSources using a provided mapper function, and handling any exceptions, null values, or ScalarDisposable cases that may arise during this process.",Tries to subscribe to a possibly Callable source s mapped ObservableSource .,Maps the emitted sources to the new ObservableSource.
private InputStream newBodyInputStream ( final DiskLruCache . Snapshot snapshot ) { return new FilterInputStream ( snapshot . getInputStream ( ENTRY_BODY ) ) { @ Override public void close ( ) throws IOException { snapshot . close ( ) ; super . close ( ) ; } } ; },"This function creates a new InputStream that reads from the 'body' entry of the provided DiskLruCache snapshot, and ensures the snapshot is closed when the stream is closed.",Returns an input stream that reads the body of a snapshot closing the snapshot when the stream is closed .,Create a stream which reads the entire stream from the given entry.
"protected void retryTimeout ( TimerImpl timer ) throws Exception { boolean callTimeout = false ; timer . lock ( ) ; try { if ( timer . isActive ( ) ) { EJB3_TIMER_LOGGER . retryingTimeout ( timer ) ; timer . setTimerState ( TimerState . RETRY_TIMEOUT , Thread . currentThread ( ) ) ; timerService . persistTimer ( timer , false ) ; callTimeout = true ; } else { EJB3_TIMER_LOGGER . timerNotActive ( timer ) ; } } finally { timer . unlock ( ) ; } if ( callTimeout ) { this . callTimeout ( timer ) ; } }","This function retries a timer timeout, handling both active and non-active timer states, logs the relevant actions, and executes a callback if timer state is set to 'RETRY_TIMEOUT'.",After a timeout failed the timer need to retried . The method must lock the timer for state check and update but not during callTimeout run .,Timeout for this timer.
"private void setHeaders ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { final Map < String , String > headers = emailWithData . headers ( ) ; if ( headers != null ) { for ( final Map . Entry < String , String > entry : headers . entrySet ( ) ) { msgToSet . setHeader ( entry . getKey ( ) , entry . getValue ( ) ) ; } } }","This function assigns the headers from the given Email object to a MimeMessage object, if the headers exist.",Sets headers in msgToSet with headers from emailWithData .,Sets the headers of the sent email address to the MimeMessage object.
"public void writeDataPage ( int valueCount , int uncompressedPageSize , BytesInput bytes , Statistics statistics , long rowCount , Encoding rlEncoding , Encoding dlEncoding , Encoding valuesEncoding ) throws IOException { long beforeHeader = out . getPos ( ) ; innerWriteDataPage ( valueCount , uncompressedPageSize , bytes , statistics , rlEncoding , dlEncoding , valuesEncoding ) ; offsetIndexBuilder . add ( ( int ) ( out . getPos ( ) - beforeHeader ) , rowCount ) ; }","This function writes a data page comprising of various encoding methods, statistics, byte inputs, uncompressed page size, and value count, while also tracking the position of the file pointer before writing the header and updating its offset index.",Writes a single page,Write a header to the given data page.
"public static final String getPojoSetter ( ProtobufAttribute protobufAttribute , Field field ) { final String fieldName = field . getName ( ) ; final String upperClassName = field . getDeclaringClass ( ) . getCanonicalName ( ) ; // Look at the cache first Map < String , String > map = CLASS_TO_FIELD_SETTERS_MAP_CACHE . get ( upperClassName ) ; if ( map != null ) { if ( ! map . isEmpty ( ) && map . containsKey ( fieldName ) ) { return map . get ( fieldName ) ; } } else { map = new ConcurrentHashMap <> ( ) ; } final String upperCaseFirstFieldName = JStringUtils . upperCaseFirst ( field . getName ( ) ) ; String setter = ""set"" + upperCaseFirstFieldName ; if ( ! protobufAttribute . pojoSetter ( ) . isEmpty ( ) ) { return protobufAttribute . pojoSetter ( ) ; } map . put ( fieldName , setter ) ; CLASS_TO_FIELD_SETTERS_MAP_CACHE . put ( upperClassName , map ) ; return setter ; }","This function retrieves the setter method name for a given field in a POJO from a cache, generating and storing it in the cache if it doesn't exist yet.",Retrieve the setter on the POJO class ; default is to is set plus upper case first character of the field name .,Gets the setter method name for a field.
"private Record parseResponse ( InputStream response ) throws StageException { Record record = null ; if ( conf . httpMethod == HttpMethod . HEAD ) { // Head will have no body so can't be parsed.   Return an empty record. record = getContext ( ) . createRecord ( """" ) ; record . set ( Field . create ( new HashMap ( ) ) ) ; } else if ( response != null ) { try ( DataParser parser = parserFactory . getParser ( """" , response , ""0"" ) ) { // A response may only contain a single record, so we only parse it once. record = parser . parse ( ) ; if ( conf . dataFormat == DataFormat . TEXT ) { // Output is placed in a field ""/text"" so we remove it here. record . set ( record . get ( ""/text"" ) ) ; } } catch ( IOException | DataParserException e ) { errorRecordHandler . onError ( Errors . HTTP_00 , e . toString ( ) , e ) ; } } return record ; }","This function parses an HTTP response based on the specified method, creating an empty record for HEAD methods or extracting a single record from the response body for other methods, handling any parsing exceptions.",Parses the HTTP response text from a request into SDC Records,Parse an HTTP response.
"public static InputStream getResourceAsStream ( String name , ClassLoader classLoader ) throws IOException { URL url = getResource ( name , classLoader ) ; if ( url != null ) { return url . openStream ( ) ; } return null ; }","This function utilizes a ClassLoader to locate a resource by name and return it as an InputStream; if the resource isn't found, it returns null.",Returns an input stream for reading the specified resource .,Finds resource with the specified class lender. If the name of the class carrier is unknown then the source will be returned if the value of this class is null  - returns a nul occurrence based on the local class name s assigned ; and assuming the actual value is not found in the current class will not be found!
"public HashMap < String , Object > export ( ) { HashMap < String , Object > data = new HashMap <> ( ) ; for ( int i = 0 ; i < queue . size ( ) ; i ++ ) { data . put ( QUEUE_DESCRIPTOR + i , queue . get ( i ) . export ( ) ) ; } for ( int i = 0 ; i < playbackModes . size ( ) ; i ++ ) { data . put ( PLAYBACK_MODE_DESCRIPTOR + i , playbackModes . get ( i ) . name ( ) ) ; } data . put ( NAME_DESCRIPTOR , name ) ; data . put ( POSITION_DESCRIPTOR , position ) ; data . put ( DATA_DESCRIPTOR , this . data ) ; return data ; }","This function exports the queue, playback modes, name, position, and data as a HashMap with string descriptors as keys and the corresponding data as values.",exports the Playlist to a HashMap,Export the values of this HttMap to YTtd.
"@ Override protected void renderView ( final ActionRequest actionRequest , final String target ) throws Exception { HttpServletRequest request = actionRequest . getHttpServletRequest ( ) ; HttpServletResponse response = actionRequest . getHttpServletResponse ( ) ; RequestDispatcher dispatcher = request . getRequestDispatcher ( target ) ; if ( dispatcher == null ) { response . sendError ( SC_NOT_FOUND , ""Result not found: "" + target ) ; // should never happened return ; } // If we're included, then include the view, otherwise do forward. // This allow the page to, for example, set content type. if ( DispatcherUtil . isPageIncluded ( request , response ) ) { dispatcher . include ( request , response ) ; } else { dispatcher . forward ( request , response ) ; } }","This function handles rendering of a view based on the given ActionRequest and target; it utilises a RequestDispatcher to either forward or include the view, or return an error if the target is not found.",Renders the view by dispatching to the target JSP .,This method handles rendering a view from the given Request Request or target.
"private static PersistenceProviderAdaptor savePerDeploymentSharedPersistenceProviderAdaptor ( DeploymentUnit deploymentUnit , String adaptorModule , PersistenceProviderAdaptor adaptor , PersistenceProvider provider ) { if ( deploymentUnit . getParent ( ) != null ) { deploymentUnit = deploymentUnit . getParent ( ) ; } synchronized ( deploymentUnit ) { Map < String , PersistenceProviderAdaptor > map = deploymentUnit . getAttachment ( providerAdaptorMapKey ) ; String key ; if ( adaptorModule != null ) { key = adaptorModule ; // handle legacy adapter module } else { key = provider . getClass ( ) . getName ( ) ; } PersistenceProviderAdaptor current = map . get ( key ) ; // saved if not already set by another thread if ( current == null ) { map . put ( key , adaptor ) ; current = adaptor ; } return current ; } }","This function saves a `PersistenceProviderAdaptor` per deployment unit, ensuring thread safety, and accommodating for legacy adapter modules.",Will save the PersistenceProviderAdaptor at the top level application deployment unit level for sharing with other persistence units,Adapter per deployment unit.
"@ Override public < T > T removeProperty ( final String key ) { if ( checkDeletedInTx ( ) ) throw new IllegalStateException ( ""The vertex "" + getIdentity ( ) + "" has been deleted"" ) ; final OrientBaseGraph graph = getGraph ( ) ; if ( graph != null ) graph . autoStartTransaction ( ) ; final Object oldValue = getRecord ( ) . removeField ( key ) ; if ( graph != null ) save ( ) ; return ( T ) oldValue ; }","This function removes a property from a vertex, and throws an exception if the vertex has been deleted, ensuring transactions are started before property removal.",Removes a Property .,Removes the property from the vertex.
"public static String getRequest ( HttpServletRequest req ) { String query = req . getQueryString ( ) ; return getRequestBase ( req ) + ( query == null ? """" : ""?"" + query ) ; }","This function retrieves the query string from an HTTPServletRequest and appends it to the base request string, returning the updated request string.",The entire request including query string,Returns the value of the request string specified in the header.
public static MultiTypeData getMultiTypeData ( char c ) { // Convert the value to a String and return the set of types that that String can be converted to. MultiTypeData result = getMultiTypeData ( Character . toString ( c ) ) ; result . nativeType = CHAR ; return result ; },This function converts a char to a string and returns a MultiTypeData object which contains the different data types that the char can be converted into.,Converts a char into a multi type data object .,Returns a MultiTypeData object containing the types of the object which can be converted from char to bchar.
"private static Object makeValue ( String string , Schema schema ) { if ( string == null ) { return null ; } try { switch ( schema . getType ( ) ) { case BOOLEAN : return Boolean . valueOf ( string ) ; case STRING : return string ; case FLOAT : return Float . valueOf ( string ) ; case DOUBLE : return Double . valueOf ( string ) ; case INT : return Integer . valueOf ( string ) ; case LONG : return Long . valueOf ( string ) ; case ENUM : // TODO: translate to enum class if ( schema . hasEnumSymbol ( string ) ) { return string ; } else { try { return schema . getEnumSymbols ( ) . get ( Integer . parseInt ( string ) ) ; } catch ( IndexOutOfBoundsException ex ) { return null ; } } case UNION : Object value = null ; for ( Schema possible : schema . getTypes ( ) ) { value = makeValue ( string , possible ) ; if ( value != null ) { return value ; } } return null ; case NULL : return null ; default : // FIXED, BYTES, MAP, ARRAY, RECORD are not supported throw new RecordException ( ""Unsupported field type:"" + schema . getType ( ) ) ; } } catch ( NumberFormatException e ) { // empty string is considered null for numeric types if ( string . isEmpty ( ) ) { return null ; } else { throw e ; } } }","This function converts a given input string into a specific type based on the provided Schema, supporting conversion into BOOLEAN, STRING, FLOAT, DOUBLE, INT, LONG, ENUM and UNION types, while other types are not supported and will throw a RecordException.",Returns a the value as the first matching schema type or null .,Converts the given input string into a specific type based on the schema.
"protected Set < Locator > getLocators ( RollupExecutionContext executionContext , boolean isReroll , Granularity delayedMetricsRerollGranularity , Granularity delayedMetricsStorageGranularity ) { Set < Locator > locators = new HashSet < Locator > ( ) ; //if delayed metric tracking is enabled, if its re-roll, if slot granularity is no coarser than // DELAYED_METRICS_REROLL_GRANULARITY, get delayed locators if ( RECORD_DELAYED_METRICS && isReroll && ! getGranularity ( ) . isCoarser ( delayedMetricsRerollGranularity ) ) { if ( getGranularity ( ) . isCoarser ( delayedMetricsStorageGranularity ) ) { // For example, if we are re-rolling a 60m slot, and we store delayed metrics at 20m, we need to // grab delayed metrics for 3 * 20m slots corresponding to the 60m slot. for ( SlotKey slotKey : parentSlotKey . getChildrenKeys ( delayedMetricsStorageGranularity ) ) { locators . addAll ( getDelayedLocators ( executionContext , slotKey ) ) ; } } else { locators = getDelayedLocators ( executionContext , parentSlotKey . extrapolate ( delayedMetricsStorageGranularity ) ) ; } } else { locators = getLocators ( executionContext ) ; } return locators ; }","This function retrieves sets of locators based on the rollup execution context and reroll status, and adjusts granularity if delayed metrics tracking is enabled.",This methods gets locators to rollup a slot .,Returns locators for the context of rollup execution. The locator sets are specified in the status report ; and if the rolldown delay is enabled it returns a granularity when the delay occurs
"@ Override public void putAll ( Map < ? extends K , ? extends V > m ) { int numKeysToBeAdded = m . size ( ) ; if ( numKeysToBeAdded == 0 ) return ; /*
         * Expand the map if the map if the number of mappings to be added
         * is greater than or equal to threshold.  This is conservative; the
         * obvious condition is (m.size() + size) >= threshold, but this
         * condition could result in a map with twice the appropriate capacity,
         * if the keys to be added overlap with the keys already in this map.
         * By using the conservative calculation, we subject ourself
         * to at most one extra resize.
         */ if ( numKeysToBeAdded > threshold ) { int targetCapacity = ( int ) ( numKeysToBeAdded / loadFactor + 1 ) ; if ( targetCapacity > MAXIMUM_CAPACITY ) targetCapacity = MAXIMUM_CAPACITY ; int newCapacity = table . length ; while ( newCapacity < targetCapacity ) newCapacity <<= 1 ; if ( newCapacity > table . length ) resize ( newCapacity ) ; } for ( Iterator < ? extends Map . Entry < ? extends K , ? extends V > > i = m . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Map . Entry < ? extends K , ? extends V > e = i . next ( ) ; put ( e . getKey ( ) , e . getValue ( ) ) ; } }","This function adds all of the mappings from the specified map to the current map, expanding the current map's capacity if necessary, and replacing any keys that currently exist in the map with the new ones.",Copies all of the mappings from the specified map to this map These mappings will replace any mappings that this map had for any of the keys currently in the specified map .,Adds the mappings that are assigned to the given map.
"private void addConstantDynamicOrInvokeDynamicReference ( final int tag , final int index , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; add ( new Entry ( index , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }","This function adds a dynamic or invoke dynamic constant reference to the index, based on the specified tag, name, descriptor, and the bootstrap method index, and then updates the hash code.",Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table .,Adds a dynamic reference to the bootstrap index.
"public static void addCacheDependencies ( Classification cacheType , Properties properties ) { for ( EventListener eventListener : eventListeners ) { eventListener . addCacheDependencies ( cacheType , properties ) ; } }","This function adds cache dependencies to each eventListener within the eventListeners list, based on the given cacheType and properties.",add cache dependencies,Adds the dependencies in cache to each event organizer.
"public List < Response > bulk ( List < ? > objects , boolean newEdits ) { assertNotEmpty ( objects , ""objects"" ) ; HttpResponse response = null ; try { final String newEditsVal = newEdits ? ""\""new_edits\"": true, "" : ""\""new_edits\"": false, "" ; final String json = String . format ( ""{%s%s%s}"" , newEditsVal , ""\""docs\"": "" , getGson ( ) . toJson ( objects ) ) ; final URI uri = buildUri ( getDBUri ( ) ) . path ( ""_bulk_docs"" ) . build ( ) ; response = post ( uri , json ) ; return getResponseList ( response ) ; } finally { close ( response ) ; } }","This function bulk updates documents with the received list of objects, signaling whether they are new edits or not, and returns a list of HTTP responses for each object update.",Performs bulk documents create and update request .,Update all documents with the given list of edits.
public static int [ ] factorsOf ( final int pn ) { int n = pn ; final boolean isPrime [ ] = primeSieve ( n ) ; // primes <= n final ICommonsList < Integer > v = new CommonsArrayList <> ( ) ; // Loop to try prime divisors. for ( int factor = 2 ; n > 1 ; ++ factor ) { if ( isPrime [ factor ] && ( n % factor == 0 ) ) { // Prime divisor found. v . add ( Integer . valueOf ( factor ) ) ; // Factor out multiples of the divisor. do { n /= factor ; } while ( n % factor == 0 ) ; } } // Create an array of the distinct prime factors. final int factors [ ] = new int [ v . size ( ) ] ; for ( int i = 0 ; i < v . size ( ) ; ++ i ) { factors [ i ] = v . get ( i ) . intValue ( ) ; } return factors ; },This function retrieves an array of all unique prime factors of a given integer 'pn' using a sieve algorithm.,Compute the prime factors of an integer value .,Retrieves the prime factors of a given integer.
"synchronized void addListener ( final String target , final int scope , final NamingListener namingListener ) { final TargetScope targetScope = new TargetScope ( target , scope ) ; // Do we have a holder for this listener ListenerHolder holder = holdersByListener . get ( namingListener ) ; if ( holder == null ) { holder = new ListenerHolder ( namingListener , targetScope ) ; final Map < NamingListener , ListenerHolder > byListenerCopy = new FastCopyHashMap < NamingListener , ListenerHolder > ( holdersByListener ) ; byListenerCopy . put ( namingListener , holder ) ; holdersByListener = byListenerCopy ; } else { holder . addTarget ( targetScope ) ; } List < ListenerHolder > holdersForTarget = holdersByTarget . get ( targetScope ) ; if ( holdersForTarget == null ) { holdersForTarget = new CopyOnWriteArrayList < ListenerHolder > ( ) ; final Map < TargetScope , List < ListenerHolder > > byTargetCopy = new FastCopyHashMap < TargetScope , List < ListenerHolder > > ( holdersByTarget ) ; byTargetCopy . put ( targetScope , holdersForTarget ) ; holdersByTarget = byTargetCopy ; } holdersForTarget . add ( holder ) ; }","This function adds a NamingListener to a specified target and scope, creating a new ListenerHolder if none exists for this listener, and storing the ListenerHolder in two maps: one by listener and one by target.",Add a listener to the coordinator with a given target name and event scope . This information is used when an event is fired to determine whether or not to fire this listener .,NamingListener to be used for assigning ListenerHolder.
"public void schedulePrune ( final long delay ) { if ( pruneTimer != null ) { pruneTimer . cancel ( ) ; } pruneTimer = new Timer ( ) ; pruneTimer . schedule ( new TimerTask ( ) { @ Override public void run ( ) { prune ( ) ; } } , delay , delay ) ; }",This function schedules a pruning operation using a timer which executes after a certain delay and cancels any previous pruning timer if exists.,Schedules prune .,Schedules an operation with a timer.
"public void setCount ( String str ) { isDefault = false ; if ( str . equals ( ""1"" ) ) { isDefault = true ; } count = str ; }","This function sets the count value to the given string input and changes the isDefault boolean to false, unless the input string is ""1"", in which case isDefault is set to true.",method to change the default count of one to the user - defined,Set the count value for this input string.
"public void setNetcdfFile ( NetcdfFile ncf ) { this . ncfile = ncf ; this . filename = ncf . getLocation ( ) ; final GetDataRunnable runner = new GetDataRunnable ( ) { public void run ( Object o ) throws IOException { final StringWriter sw = new StringWriter ( 50000 ) ; NCdumpW . print ( ncfile , command , sw , task ) ; result = sw . toString ( ) ; } } ; task = new GetDataTask ( runner , filename , null ) ; stopButton . startProgressMonitorTask ( task ) ; }","This function sets the NetcdfFile, updates the filename, creates a new runnable to retrieve and store the data from the file, starts a new task with this runnable, and initiates the progress monitor task with the stop button.",allow calling from outside,Set progress monitor the upload file.
public boolean attachTimer ( TimerID timerID ) { if ( cacheData . attachTimer ( timerID ) ) { if ( acReferencesHandler != null ) { acReferencesHandler . timerReferenceCreated ( ) ; } return true ; } else { return false ; } },"This function attempts to attach a timer with a given ID to the cache data, and if successful, it notifies a references handler (if exists), returning true; otherwise, fails and returns false.",attach the given timer to the current activity context .,Attach the given timer to the cache. If successful the reference handler is not present - if so throws out a false handle!
"public void verifyAndCreateTempTables ( ) { ZonedDateTime currentBlock = ZonedDateTime . ofInstant ( Instant . ofEpochMilli ( DateTimeService . now . get ( ) . getMillis ( ) ) , UTC ) . with ( DateTimeService . startOfPreviousEvenHour ( ) ) ; ZonedDateTime lastStartupBlock = currentBlock . plus ( 6 , ChronoUnit . HOURS ) ; verifyAndCreateTempTables ( currentBlock , lastStartupBlock ) . await ( ) ; }","This function verifies and creates temporary tables, calculating the current time block and the time block six hours prior, then awaiting for the operation to complete.",Intended to be used at the startup of the MetricsServiceImpl to ensure we have enough tables for processing,Verify the complete construction project.
static RunAs popRunAsIdentity ( final SecurityContext sc ) { if ( WildFlySecurityManager . isChecking ( ) ) { return AccessController . doPrivileged ( new PrivilegedAction < RunAs > ( ) { @ Override public RunAs run ( ) { if ( sc == null ) { throw UndertowLogger . ROOT_LOGGER . noSecurityContext ( ) ; } RunAs principal = sc . getOutgoingRunAs ( ) ; sc . setOutgoingRunAs ( null ) ; return principal ; } } ) ; } else { if ( sc == null ) { throw UndertowLogger . ROOT_LOGGER . noSecurityContext ( ) ; } RunAs principal = sc . getOutgoingRunAs ( ) ; sc . setOutgoingRunAs ( null ) ; return principal ; } },"This function retrieves and erases the outgoing RunAs identity from the given SecurityContext, throwing an error if the SecurityContext is null, and handles the security check through WildFlySecurityManager and AccessController.",Removes the run as identity,This method is used to remove all the security checks that are done by this method.
public String applyToColumnName ( final String columnName ) { String propertyName = convertColumnNameToPropertyName ( columnName ) ; return convertPropertyNameToColumnName ( propertyName ) ; },This function converts a given database column name into a property name and then back to its equivalent column name.,Applies column naming strategy to given column name hint . Returns full column name .,Returns the column name of the database.
private String consumeCommentTokens ( String line ) { if ( line . indexOf ( START_COMMENT ) == - 1 && line . indexOf ( END_COMMENT ) == - 1 ) { return line ; } while ( ( line = consume ( line ) ) != null ) { if ( ! this . inComment && ! line . trim ( ) . startsWith ( START_COMMENT ) ) { return line ; } } return line ; },This function removes all comment tokens from the input string line and returns the modified line.,Consumes all the leading comment data in the given String and returns the remaining content which may be empty since the supplied content might be all comment data . For our purposes it is only important to strip leading comment content on a line since the first piece of non comment content will be either the DOCTYPE declaration or the root element of the document .,Removes comment tokens from string.
"public static void createInheritanceLink ( CtClass concreteClass , CtClass superClass ) { if ( superClass == null ) return ; try { concreteClass . setSuperclass ( superClass ) ; logger . trace ( concreteClass . getName ( ) + "" Inheritance link with "" + superClass . getName ( ) + "" class created"" ) ; } catch ( CannotCompileException cce ) { cce . printStackTrace ( ) ; } }",This function is used to create an inheritance link between a concrete class and its superclass and logs a message upon successful operation.,Create the inheritance link with the sbb absract class provided by the sbb developer,Creates a link to the superclass of lone.
public java . util . Collection < Codec . ID > getSupportedCodecs ( ) { final java . util . List < Codec . ID > retval = new java . util . LinkedList < Codec . ID > ( ) ; final java . util . Set < Codec . ID > uniqueSet = new java . util . HashSet < Codec . ID > ( ) ; int numCodecs = getNumSupportedCodecs ( ) ; for ( int i = 0 ; i < numCodecs ; i ++ ) { Codec . ID id = getSupportedCodecId ( i ) ; // remove duplicate IDs if ( id != Codec . ID . CODEC_ID_NONE && ! uniqueSet . contains ( id ) ) retval . add ( id ) ; uniqueSet . add ( id ) ; } return retval ; },This function returns a collection of unique supported codec IDs.,Returns a list of all codecs supported for this Object .,Returns a collection of codec ids that are supported by the code.
"public String toHELM2 ( ) { String output = """" ; /* first section: simple polymer section */ output += polymerToHELM2 ( ) + ""$"" ; /* second section: connection section */ output += connectionToHELM2 ( ) + ""$"" ; /* third section: grouping section */ output += groupingToHELM2 ( ) + ""$"" ; /* fourth section: annotation section */ output += annotationToHELM2 ( ) + ""$"" ; /* add version number */ output += ""V2.0"" ; return output ; }","This function converts the input into HELM2 notation format, arranged in four sections: simple polymer, connections, groupings, and annotations, and adds version number to the output.",method to generate for all sections a HELM2 string,convert the input into a HELM2 notation format.
"public static < T extends Comparable > BinarySearch < T > forList ( final List < T > list ) { return new BinarySearch < T > ( ) { @ Override @ SuppressWarnings ( { ""unchecked"" } ) protected int compare ( int index , T element ) { return list . get ( index ) . compareTo ( element ) ; } @ Override protected int getLastIndex ( ) { return list . size ( ) - 1 ; } } ; }","This function provides a way to perform binary search on a list by returning a new BinarySearch object with overridden compare and getLastIndex methods, tailored for the given list.",Creates binary search wrapper over a list of comparable elements .,Perform the long term binary search on the given list.
public void create ( ) { if ( threadSafe ) entryMap = Collections . synchronizedMap ( new HashMap ( ) ) ; else entryMap = new HashMap ( ) ; now = System . currentTimeMillis ( ) ; },"This function creates a new, optionally thread-safe map and records the current system time.",Initializes the cache for use . Prior to this the cache has no store .,Create a new and optionally thread safe map.
"public void printUsage ( final String commandName ) { final StringBuilder usage = new StringBuilder ( commandName ) ; for ( final Option option : options ) { if ( option . shortName != null ) { usage . append ( "" [-"" ) . append ( option . shortName ) . append ( ""]"" ) ; } else if ( option . longName != null ) { usage . append ( "" [--"" ) . append ( option . longName ) . append ( ""]"" ) ; } } for ( final Param param : params ) { usage . append ( "" "" ) . append ( param . label ) ; } System . out . println ( usage ) ; }","This function prints the usage information of a given command, including its options (short and long names) and parameters.",Prints the usage line .,Prints the command information about the usage of this command.
public void clear ( ) { for ( int y = 0 ; y < countY ; y ++ ) for ( int x = 0 ; x < countX ; x ++ ) gridArray [ y ] [ x ] . used = false ; },"This function iterates over the 2D grid array, setting the ""used"" status of each cell to false.",clear all the grid cells,This method initializes the 2D grid array over the current state setting the used status of each cell.
"private static String uencode ( String prefix ) { if ( prefix != null && prefix . startsWith ( ""file:"" ) ) { StringTokenizer tokens = new StringTokenizer ( prefix , ""/\\:"" , true ) ; StringBuilder stringBuilder = new StringBuilder ( ) ; while ( tokens . hasMoreElements ( ) ) { String token = tokens . nextToken ( ) ; if ( ""/"" . equals ( token ) || ""\\"" . equals ( token ) || "":"" . equals ( token ) ) { stringBuilder . append ( token ) ; } else { try { stringBuilder . append ( URLEncoder . encode ( token , ""UTF-8"" ) ) ; } catch ( java . io . UnsupportedEncodingException ex ) { } } } return stringBuilder . toString ( ) ; } else { return prefix ; } }","This function ""uencode"" is encoding special characters in a given string prefix, preserving slash, backslash, and colon intact.",END PWC 6386258,Uencodes string characters with given prefix and string encoding them.
"public static void transform ( Se2_F64 se , Point2D_F64 points [ ] , int length ) { double tranX = se . getX ( ) ; double tranY = se . getY ( ) ; final double c = se . getCosineYaw ( ) ; final double s = se . getSineYaw ( ) ; for ( int i = 0 ; i < length ; i ++ ) { Point2D_F64 pt = points [ i ] ; double x = pt . x ; double y = pt . y ; pt . x = tranX + x * c - y * s ; pt . y = tranY + x * s + y * c ; } }",This function applies a two-dimensional transformation to a specified array of points using a provided SE(2) transform object.,Applies a 2D special euclidean transform to an array of points .,Transformation twodimensionales to array of points using specified transform object
"public List < Violation > validate ( final ValidationContext ctx , final Object target , final String targetName ) { for ( Map . Entry < String , List < Check > > entry : ctx . map . entrySet ( ) ) { String name = entry . getKey ( ) ; Object value = BeanUtil . declaredSilent . getProperty ( target , name ) ; String valueName = targetName != null ? ( targetName + ' ' + name ) : name ; // move up ValidationConstraintContext vcc = new ValidationConstraintContext ( this , target , valueName ) ; for ( Check check : entry . getValue ( ) ) { String [ ] checkProfiles = check . getProfiles ( ) ; if ( ! matchProfiles ( checkProfiles ) ) { continue ; } if ( check . getSeverity ( ) < severity ) { continue ; } ValidationConstraint constraint = check . getConstraint ( ) ; if ( ! constraint . isValid ( vcc , value ) ) { addViolation ( new Violation ( valueName , target , value , check ) ) ; } } } return getViolations ( ) ; }","This function validates a target object based on a provided validation context and target name, checking each of the property constraints in the context, only considering checks which match profiles and exceeding a threshold severity, then adding any violations to a list which is returned at the end.",Performs validation of provided validation context and appends violations .,Validates the given target for a given context and target.
"public String abs2rel ( final String basePath , final String absPath ) { if ( ! isAbsolutePath ( absPath ) ) { return absPath ; } if ( isWindowsDrive ( absPath ) && isWindowsDrive ( basePath ) && absPath . charAt ( 0 ) != basePath . charAt ( 0 ) ) { return absPath ; } StringBuilder result = new StringBuilder ( ) ; String [ ] baseParts = getParts ( basePath ) ; String [ ] absParts = getParts ( absPath ) ; // extract common prefix int start = 0 ; for ( int i = 0 ; i < Math . min ( baseParts . length , absParts . length ) ; ++ i ) { if ( baseParts [ i ] . equals ( absParts [ i ] ) ) { start = i + 1 ; } } for ( int i = start ; i < baseParts . length ; ++ i ) { if ( result . length ( ) > 0 ) { result . append ( File . separator ) ; } result . append ( "".."" ) ; } for ( int i = start ; i < absParts . length ; ++ i ) { if ( result . length ( ) > 0 ) { result . append ( File . separator ) ; } result . append ( absParts [ i ] ) ; } return result . toString ( ) ; }",This function converts an absolute file path into a relative file path with respect to a given base path.,Converts an absolute path into a relative one .,Returns an absolute file path to a relative filepath.
"public ByteBuffer encodePFrame ( Picture pic , ByteBuffer _out ) { frameNumber ++ ; return doEncodeFrame ( pic , _out , true , frameNumber , SliceType . P ) ; }","This function encodes a given picture into a P-Frame, increments the frame number, and returns the encoded frame in a ByteBuffer.",Encode this picture as a P - frame . P - frame is an frame predicted from one or more of the previosly decoded frame and is usually 10x less in size then the IDR frame .,Encodes the image as a P-Frame and returns the frame as an Encoding object.
"public Attribute deleteGlobalAttribute ( String attName ) { if ( ! defineMode ) throw new UnsupportedOperationException ( ""not in define mode"" ) ; Attribute att = findGlobalAttribute ( attName ) ; if ( null == att ) return null ; rootGroup . remove ( att ) ; return att ; }","This function removes a global attribute specified by its name if the system is in define mode, returning the removed attribute, otherwise throws an UnsupportedOperationException.",Delete a global Attribute . Must be in define mode .,Removes an attribute from the list otherwise it is gone.
"public RecoveryPlan createRecoveryPlan ( final AeronArchive archive , final int serviceCount ) { final ArrayList < Snapshot > snapshots = new ArrayList <> ( ) ; final ArrayList < Log > logs = new ArrayList <> ( ) ; planRecovery ( snapshots , logs , entries , archive , serviceCount ) ; long lastLeadershipTermId = NULL_VALUE ; long lastTermBaseLogPosition = 0 ; long committedLogPosition = - 1 ; long appendedLogPosition = 0 ; final int snapshotStepsSize = snapshots . size ( ) ; if ( snapshotStepsSize > 0 ) { final Snapshot snapshot = snapshots . get ( 0 ) ; lastLeadershipTermId = snapshot . leadershipTermId ; lastTermBaseLogPosition = snapshot . termBaseLogPosition ; appendedLogPosition = snapshot . logPosition ; committedLogPosition = snapshot . logPosition ; } if ( ! logs . isEmpty ( ) ) { final Log log = logs . get ( 0 ) ; lastLeadershipTermId = log . leadershipTermId ; lastTermBaseLogPosition = log . termBaseLogPosition ; appendedLogPosition = log . stopPosition ; committedLogPosition = log . logPosition ; } return new RecoveryPlan ( lastLeadershipTermId , lastTermBaseLogPosition , appendedLogPosition , committedLogPosition , snapshots , logs ) ; }","This function generates a recovery plan by processing snapshots and logs from an archive, initializing positions for terms and logs, and finally returning a new recovery plan object.",Create a recovery plan for the cluster that when the steps are replayed will bring the cluster back to the latest stable state .,Generate a plan decovery from an archive.
"protected ComponentView getComponentView ( ) { ComponentView cv = componentView ; // we need to check both, otherwise it is possible for // componentView to be initialized before reference if ( cv == null ) { synchronized ( this ) { cv = componentView ; if ( cv == null ) { cv = getMSCService ( componentViewName , ComponentView . class ) ; if ( cv == null ) { throw WSLogger . ROOT_LOGGER . cannotFindComponentView ( componentViewName ) ; } if ( reference == null ) { try { reference = cv . createInstance ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } componentView = cv ; } } } return cv ; }","This function retrieves a componentView; if not initially found or initialized, it synchronizes the process, creates a new instance if necessary, and throws an exception if the componentView cannot be retrieved.",Gets endpoint container lazily .,Returns the component view from the given instance. If the annotation was initialized or not found it will be returned if the representation returned was not returned yet ; then the result will have to be restored - creating a new instance for the specified component s view!
public static Element parse ( InputSource source ) throws IOException { try { Document doc = getDocumentBuilder ( ) . parse ( source ) ; Element root = doc . getDocumentElement ( ) ; return root ; } catch ( SAXException e ) { throw new IOException ( e . toString ( ) ) ; } },This function attempts to parse an XML from a provided input source and returns the root element of that XML; an IOException is thrown if the XML parsing encounters any issues.,Parse the given input source and return the root Element,Parse an XML from an input source. The root element of the input is the root Element thrown!
"public static PnSignalingParams defaultInstance ( ) { MediaConstraints pcConstraints = PnSignalingParams . defaultPcConstraints ( ) ; MediaConstraints videoConstraints = PnSignalingParams . defaultVideoConstraints ( ) ; MediaConstraints audioConstraints = PnSignalingParams . defaultAudioConstraints ( ) ; List < PeerConnection . IceServer > iceServers = PnSignalingParams . defaultIceServers ( ) ; return new PnSignalingParams ( iceServers , pcConstraints , videoConstraints , audioConstraints ) ; }","This function initializes the default signaling parameters for a PeerConnection, including constraints for the PC, video, audio and a list of IceServers.",The default parameters for media constraints . Might have to tweak in future .,This method initializes the default signaling parameters for a PeerConnection.
public float [ ] getAzimuths ( ) { if ( azimuths == null ) { azimuths = new float [ nRays ] ; for ( int r = 0 ; r < nRays ; r ++ ) { azimuths [ r ] = myRYIBs [ r ] . getAzimuth ( ) ; } } return azimuths ; },"This function fetches the azimuth values for all rays; if they are not initialized, it creates a new array, populates it with azimuth data, and then returns it.",Get the array of azimuths for this sweep .,Returns the values for azimuth at all rays.
"@ Override public Observable < Observable < Row > > findAllDataFromBucket ( long timestamp , int pageSize , int maxConcurrency ) { PreparedStatement ts = getTempStatement ( MetricType . UNDEFINED , TempStatement . SCAN_WITH_TOKEN_RANGES , timestamp ) ; // The table does not exists - case such as when starting Hawkular-Metrics for the first time just before // compression kicks in. if ( ts == null || prepMap . floorKey ( timestamp ) == 0L ) { return Observable . empty ( ) ; } return Observable . from ( getTokenRanges ( ) ) . map ( tr -> rxSession . executeAndFetch ( ts . bind ( ) . setToken ( 0 , tr . getStart ( ) ) . setToken ( 1 , tr . getEnd ( ) ) . setFetchSize ( pageSize ) ) ) ; }","This function is overriding the 'findAllDataFromBucket' method to return an observable stream of all data from a specified bucket, based on the input parameters of timestamp, page size, and maximum concurrency, handling cases where the table doesn't exist as well.",Fetch all the data from a temporary table for the compression job . Using TokenRanges avoids fetching first all the metrics partition keys and then requesting them .,Returns a stream of all data from sock. The stream is based on the input parameters of the tick - bucket corresponding to the string selection if there is none!
public static Iterator names ( ) { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) sm . checkPropertiesAccess ( ) ; return props . names ( ) ; },"This function creates a security manager instance, checks for property access if the instance is not null and returns a list of property names.",Return an iterator over all contained property names .,Create a security manager with all the properties listed below.
protected void onDecoraTag ( final Tag tag ) { String tagName = tag . getName ( ) . toString ( ) ; if ( tag . getType ( ) == TagType . SELF_CLOSING ) { checkNestedDecoraTags ( ) ; decoraTagName = tagName . substring ( 7 ) ; decoraTagStart = tag . getTagPosition ( ) ; decoraTagEnd = tag . getTagPosition ( ) + tag . getTagLength ( ) ; defineDecoraTag ( ) ; return ; } if ( tag . getType ( ) == TagType . START ) { checkNestedDecoraTags ( ) ; decoraTagName = tagName . substring ( 7 ) ; decoraTagStart = tag . getTagPosition ( ) ; decoraTagDefaultValueStart = tag . getTagPosition ( ) + tag . getTagLength ( ) ; return ; } // closed tag type decoraTagEnd = tag . getTagPosition ( ) + tag . getTagLength ( ) ; decoraTagDefaultValueEnd = tag . getTagPosition ( ) ; defineDecoraTag ( ) ; },"This function processes a given Decora tag based on its type, extracts the tag name information, checks for nested tags, determines the tag's location within the source, and defines the tag within the system.",Handle Decora tags .,Process a Decora tag.
"public static String extractSymbolicName ( File jar ) throws PluginExecutionException { JarFile jarFile = null ; try { jarFile = new JarFile ( jar ) ; return jarFile . getManifest ( ) . getMainAttributes ( ) . getValue ( ""Bundle-SymbolicName"" ) ; } catch ( IOException e ) { throw new PluginExecutionException ( ""Could not load the jar "" + jar . getAbsolutePath ( ) , e ) ; } finally { if ( jarFile != null ) { try { jarFile . close ( ) ; } catch ( IOException e ) { // nothing to do here } } } }",This function extracts the symbolic name from the manifest of a given JAR file.,Extracts the bundle symbolic name from the jar manifest .,Returns the symbolic name of the JAR file.
"public String hostUrl ( ) { StringBand url = new StringBand ( 8 ) ; if ( protocol != null ) { url . append ( protocol ) ; url . append ( ""://"" ) ; } if ( host != null ) { url . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { url . append ( ' ' ) ; url . append ( port ) ; } return url . toString ( ) ; }","This function concatenates protocol, host, and port to form a complete host URL, if they exist and the port is not set to default.",Returns just host url without path and query .,Constructs a complete URL to the host.
"private void writeMode ( ) throws SLEEException , ManagementException { if ( ! isProfileWriteable ( ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( ""Changing state to read-write, for profile mbean with name "" + profileName + "", from table with name "" + this . profileTable . getProfileTableName ( ) ) ; } // get object & make it writable ProfileObjectImpl profileObject = profileTable . getProfile ( profileName ) ; profileObject . getProfileEntity ( ) . setReadOnly ( false ) ; // change state state = State . write ; } else { if ( logger . isDebugEnabled ( ) ) { logger . debug ( ""Already in write state, for profile mbean with name "" + profileName + "", from table with name "" + this . profileTable . getProfileTableName ( ) ) ; } } }","This function changes the state of a profile MBean to read-write mode if it is currently not writable, throwing SLEEException and ManagementException if there's an error; the current state and the profile's name and table are logged.",Moves to the write mode using specified object . The current java transaction will be suspended .,Read a profile.
"public synchronized void reset ( ) { if ( strategy == Strategy . ACTION_MANAGED ) { actionBundles . clear ( ) ; mirrors . clear ( ) ; } final FindFile ff = new FindFile ( ) ; ff . includeDirs ( false ) ; ff . searchPath ( new File ( bundleFolder , staplerPath ) ) ; File f ; int count = 0 ; while ( ( f = ff . nextFile ( ) ) != null ) { f . delete ( ) ; count ++ ; } if ( log . isInfoEnabled ( ) ) { log . info ( ""reset: "" + count + "" bundle files deleted."" ) ; } }",This function resets the strategy by deleting files under a particular path and logging the number of files deleted.,Clears all settings and removes all created bundle files from file system .,Delete all files from the given path.
"public void put ( String name , Object value ) { pageContext . setAttribute ( name , value , scope ) ; }","This function adds a new attribute to the pageContext object using the provided name and value parameters, with the specified scope.",Inserts an object into the scope .,Adds a new attribute to the provided context.
"public static void writeObject ( ObjectOutputStream out , Object vendorData ) throws IOException { // write non-transient fields out . defaultWriteObject ( ) ; // check if should we serialize vendor data? if ( vendorData != null ) { // serialize the vendor data out . writeBoolean ( true ) ; // write the vendor data in a marshalled object so deserialization can be deferred out . writeObject ( new MarshalledObject ( vendorData ) ) ; } else out . writeBoolean ( false ) ; }","This function serializes non-transient fields and checks whether vendor data is present; if so, it serializes the vendor data into a MarshalledObject, else it writes a boolean false.",Write the current object and vendor - specific data to the output stream .,serializes the non - transit fields.
"@ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int capacityHint , Runnable onCancelled ) { ObjectHelper . requireNonNull ( onCancelled , ""onTerminate"" ) ; return new UnicastProcessor < T > ( capacityHint , onCancelled ) ; }","This function creates a new UnicastProcessor with a defined capacityHint and onCancelled Runnable, throwing a NullPointerException if the onCancelled is absent.",Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .,Creates a new UnicastProcessor with defined capacity.
public CoordinateTransform findCoordinateTransform ( String name ) { if ( name == null ) return null ; for ( CoordinateTransform v : coordTransforms ) { if ( name . equals ( v . getName ( ) ) ) return v ; } return null ; },"This function searches for and returns a CoordinateTransform object from the coordTransforms list by its name, or returns null if the name is null or no matching name is found.",Retrieve the CoordinateTransform with the specified name .,Find or return coordinateform for koordtransform.
"private void enlarge ( ) { int oldCapacity = keys . length ; if ( oldCapacity == LinearProbing . MAXIMUM_CAPACITY ) throw new IllegalArgumentException ( ""Map cannot grow beyond capacity: "" + LinearProbing . MAXIMUM_CAPACITY ) ; K oldKeys [ ] = keys ; V oldValues [ ] = values ; int newCapacity = oldCapacity << 1 ; @ SuppressWarnings ( ""unchecked"" ) K newKeys [ ] = ( K [ ] ) new Object [ newCapacity ] ; @ SuppressWarnings ( ""unchecked"" ) V newValues [ ] = ( V [ ] ) new Object [ newCapacity ] ; for ( int i = 0 ; i < oldCapacity ; i ++ ) { K key = oldKeys [ i ] ; if ( key != null ) putKeyValue ( newKeys , newValues , key , oldValues [ i ] ) ; } this . keys = newKeys ; this . values = newValues ; }","Increases the size of the keys and values arrays by doubling their capacity, if the old capacity has not reached the maximum limit.",Increasing the capacity of the map,Added new capacity to the limit for scaling values.
private static boolean hasSameVersionOfCglib ( ClassLoader classLoader ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return classLoader . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return false ; } },This function checks if the provided class loader has the same version of Cglib by attempting to load the FastClass from it.,Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .,Loads the current class with the same version as Cglib.
Response delete ( URI uri ) { HttpResponse response = null ; try { HttpDelete delete = new HttpDelete ( uri ) ; response = executeRequest ( delete ) ; return getResponse ( response ) ; } finally { close ( response ) ; } },"This function deletes a specified URI and returns the server response, ensuring the HttpResponse connection is closed afterwards irrespective of the outcome.",Performs a HTTP DELETE request .,Returned after deleting response.
"public static String join ( final List < String > list ) { // zero, empty or one element if ( list == null ) { return null ; } else if ( list . size ( ) == 0 ) { return """" ; } else if ( list . size ( ) == 1 ) { return list . get ( 0 ) ; } // two or more elements final StringBuilder builder = new StringBuilder ( ) ; for ( String item : list ) { if ( builder . length ( ) > 0 ) { builder . append ( "", "" ) ; } builder . append ( item ) ; } return builder . toString ( ) ; }","This function converts a list of Strings into a single, comma-separated String, returning null for a null input, an empty String for empty list input, and the single String for one-element list input.",Joins items of a text list separating items by comma .,Returns a String from comma.
"private boolean awaitWork ( WorkQueue w , int r ) { if ( w == null || w . qlock < 0 ) // w is terminating return false ; for ( int pred = w . stackPred , spins = SPINS , ss ; ; ) { if ( ( ss = w . scanState ) >= 0 ) break ; else if ( spins > 0 ) { r ^= r << 6 ; r ^= r >>> 21 ; r ^= r << 7 ; if ( r >= 0 && -- spins == 0 ) { // randomize spins WorkQueue v ; WorkQueue [ ] ws ; int s , j ; AtomicLong sc ; if ( pred != 0 && ( ws = workQueues ) != null && ( j = pred & SMASK ) < ws . length && ( v = ws [ j ] ) != null && // see if pred parking ( v . parker == null || v . scanState >= 0 ) ) spins = SPINS ; // continue spinning } } else if ( w . qlock < 0 ) // recheck after spins return false ; else if ( ! Thread . interrupted ( ) ) { long c , prevctl , parkTime , deadline ; int ac = ( int ) ( ( c = ctl ) >> AC_SHIFT ) + ( config & SMASK ) ; if ( ( ac <= 0 && tryTerminate ( false , false ) ) || ( runState & STOP ) != 0 ) // pool terminating return false ; if ( ac <= 0 && ss == ( int ) c ) { // is last waiter prevctl = ( UC_MASK & ( c + AC_UNIT ) ) | ( SP_MASK & pred ) ; int t = ( short ) ( c >>> TC_SHIFT ) ; // shrink excess spares if ( t > 2 && U . compareAndSwapLong ( this , CTL , c , prevctl ) ) return false ; // else use timed wait parkTime = IDLE_TIMEOUT * ( ( t >= 0 ) ? 1 : 1 - t ) ; deadline = System . nanoTime ( ) + parkTime - TIMEOUT_SLOP ; } else prevctl = parkTime = deadline = 0L ; Thread wt = Thread . currentThread ( ) ; U . putObject ( wt , PARKBLOCKER , this ) ; // emulate LockSupport w . parker = wt ; if ( w . scanState < 0 && ctl == c ) // recheck before park U . park ( false , parkTime ) ; U . putOrderedObject ( w , QPARKER , null ) ; U . putObject ( wt , PARKBLOCKER , null ) ; if ( w . scanState >= 0 ) break ; if ( parkTime != 0L && ctl == c && deadline - System . nanoTime ( ) <= 0L && U . compareAndSwapLong ( this , CTL , c , prevctl ) ) return false ; // shrink pool } } return true ; }","This function awaits the work on the WorkQueue 'w', spinning if necessary, then parks the thread if there is no work in 'w' or if the work queue is locked; returns false if the work queue is terminating or the thread pool is terminating.",Possibly blocks worker w waiting for a task to steal or returns false if the worker should terminate . If inactivating w has caused the pool to become quiescent checks for pool termination and so long as this is not the only worker waits for up to a given duration . On timeout if ctl has not changed terminates the worker which will in turn wake up another worker to possibly repeat this process .,Waits till all work is done on w before the queue is finished. The wait wait is filled and the pool of threads is closed!
